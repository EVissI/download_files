<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backgammon Game Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            color: white;
            background-color: #1a1a1a;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        h1 {
            display: none;
        }

        canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background-color: #2a2a2a;
            max-width: 100%;
            height: 100%;
            display: block;
            margin: 0 auto 20px;
        }

        .game-info {
            background-color: #2d2d2d;
            border-radius: 8px;
            padding: 10px;
            margin: 0;
            border: 1px solid #444;
            width: 30%;
            display: block;
        }

        .hints-table {
            background-color: #2d2d2d;
            border-radius: 8px;
            border: 1px solid #444;
            overflow-x: auto;
        }

        .hints-buttons {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .hint-toggle-btn {
            width: 49%;
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .hint-toggle-btn:hover {
            background-color: #0056b3;
        }

        .hint-toggle-btn.active {
            background-color: #0056b3;
        }

        .hints-buttons button:hover {
            background-color: #0056b3;
        }

        .hints-buttons button.active {
            background-color: #0056b3;
        }

        .hints-content {
            display: none;
            position: relative;
        }

        .hints-content.active {
            display: block;
        }

        table {
            margin: 0 auto;
            border-collapse: collapse;
            width: 100%;
            max-width: 800px;
            background-color: #333;
            border-radius: 6px;
            overflow: hidden;
        }

        th,
        td {
            border: 1px solid #555;
            padding: 20px 30px;
            text-align: left;
            color: white;
            word-spacing: 16px;
        }

        td:nth-child(2),
        td:nth-child(3),
        td:nth-child(4) {
            text-align: center;
        }

        th {
            background-color: #444;
            font-weight: bold;
            text-align: center;
        }

        tr:nth-child(even) {
            background-color: #2a2a2a;
        }

        tr:hover {
            background-color: #3a3a3a;
        }

        .hint-best {
            background-color: #2e7d32 !important;
        }

        .hint-good {
            background-color: #fbc02d !important;
        }

        .hint-good td {
            color: #1a1a1a !important;
        }

        .hint-poor {
            background-color: #d32f2f !important;
        }

        #top-row {
            margin: 0px 0 10px 0;
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            align-items: center;
            width: 100%;
        }

        #controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            gap: 20px;
        }

        .screenshot-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            justify-content: center;
        }

        .navigation-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            height: 64px;
            /* Высота двух рядов кнопок (32px * 2) */
            justify-content: center;
        }

        .turn-display {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #turnLabel {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
            margin: 0;
            min-width: 60px;
            text-align: center;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        .game-select {
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: white;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 5px;
        }

        .settings-modal select {
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: white;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 5px;
            box-sizing: border-box;
            display: block;
        }

        #prevBtn,
        #nextBtn {
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: 42px;
            height: 42px;
            padding: 0;
            color: transparent;
            background-color: transparent;
            border: none;
        }

        #invertBtn,
        #screenshotBtn,
        #screenSaveBtn,
        #screenUploadBtn {
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: 32px;
            height: 32px;
            padding: 0;
            color: transparent;
            background-color: transparent;
            border: none;
        }


        #prevBtn:hover,
        #nextBtn:hover,
        #invertBtn:hover,
        #screenshotBtn:hover,
        #screenSaveBtn:hover,
        #screenUploadBtn:hover {
            background-color: transparent;
        }

        #prevBtn:disabled,
        #nextBtn:disabled,
        #invertBtn:disabled,
        #screenshotBtn:disabled,
        #screenSaveBtn:disabled,
        #screenUploadBtn:disabled {
            opacity: 0.5;
            background-color: transparent;
        }


        .info-text {
            color: #ccc;
            margin: 5px 0;
        }


        .board-footer {
            position: relative;
            margin-top: -20px;
        }

        .move-info {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
            text-align: center;
        }

        .pips-below-board {
            position: absolute;
            right: 0;
            top: 0;
            margin: 0;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 2rem;
            }

            .pips-above-board,
            .pips-below-board {
                font-size: 16px;
                padding: 8px 16px;
            }

            canvas {
                width: 100%;
                height: 100%;
            }

            #top-row {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                justify-content: space-between;
                width: 100%;
            }

            #controls {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                justify-content: center;
                width: 100%;
            }

            #turnLabel {
                margin: 5px 0;
                font-size: 20px;
            }

            #top-row {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                justify-content: space-between;
                width: 100%;
            }

            button {
                width: auto;
                min-width: 60px;
                padding: 10px 20px;
            }

            table {
                font-size: 24px;
            }

            th,
            td {
                padding: 8px 12px;
                word-spacing: 12px;
            }

            .container {
                padding: 0 10px;
            }

            .hints-table {
                padding: 15px;
            }

            #prevBtn,
            #nextBtn {
                width: 62px;
                height: 62px;
            }

            #invertBtn,
            #screenshotBtn,
            #screenSaveBtn,
            #screenUploadBtn,
            #supportBtn {
                width: 48px;
                height: 48px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5rem;
            }

            canvas {
                width: 100%;
                height: 100%;
            }

            button {
                width: auto;
                min-width: 60px;
                padding: 8px 16px;
                font-size: 14px;
            }

            table {
                font-size: 16px;
            }

            th,
            td {
                padding: 6px 8px;
                word-spacing: 4px;
            }

            #prevBtn,
            #nextBtn {
                width: 37px;
                height: 37px;
            }

            #invertBtn,
            #screenshotBtn,
            #screenSaveBtn,
            #screenUploadBtn,
            #supportBtn {
                width: 28px;
                height: 28px;
            }
        }

        @media (min-width: 1200px) {

            #prevBtn,
            #nextBtn {
                width: 104px;
                height: 104px;
            }

            #invertBtn,
            #screenshotBtn,
            #screenSaveBtn,
            #screenUploadBtn,
            #supportBtn {
                width: 80px;
                height: 80px;
            }
        }

        .loading {
            color: #007bff;
            font-style: italic;
        }

        .error {
            color: #dc3545;
            background-color: #2d1b1b;
            border: 1px solid #dc3545;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }

        .header {
            display: flex;
            flex-direction: column;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #hideInfoCheckbox {
            margin-right: 10px;
        }

        .animation-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
            align-items: stretch;
        }

        .animation-controls label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .right-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }


        #players-info {
            max-width: 800px;
            margin: 0 auto;
        }

        .pips-above-board {
            background-color: #000000;
            color: #ffffff;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            text-align: right;
            display: block;
            width: fit-content;
        }

        .pips-above-board-inverted {
            background-color: #ffffff;
            color: #000000;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            text-align: right;
            display: block;
            width: fit-content;
        }

        .pips-below-board-inverted {
            background-color: #000000;
            color: #ffffff;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            text-align: right;
            display: block;
            width: fit-content;
            position: absolute;
            right: 0;
            top: 0;
            margin: 0;
        }

        .pips-below-board {
            background-color: #ffffff;
            color: #000000;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            text-align: right;
            display: block;
            width: fit-content;
        }

        /* Снежинки */
        .snowflake {
            position: fixed;
            top: -50px;
            z-index: -1;
            user-select: none;
            pointer-events: none;
            font-size: 1.5em;
            color: #ffffff;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
            opacity: 0.8;
        }

        @keyframes snowfall {
            0% {
                transform: translateY(0) translateX(0) rotate(0deg);
                opacity: 0.8;
            }

            50% {
                opacity: 0.9;
            }

            100% {
                transform: translateY(100vh) translateX(100px) rotate(360deg);
                opacity: 0.3;
            }
        }

        @keyframes snowfall-left {
            0% {
                transform: translateY(0) translateX(0) rotate(0deg);
                opacity: 0.8;
            }

            50% {
                opacity: 0.9;
            }

            100% {
                transform: translateY(100vh) translateX(-100px) rotate(360deg);
                opacity: 0.3;
            }
        }

        /* Support Button and Modal */
        .settings-container {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            margin: 20px 0 10px 0;
            color: #ccc;
            font-size: 16px;
        }

        .support-container {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            margin: 0 0 20px 0;
            color: #ccc;
            font-size: 16px;
        }

        #supportBtn {
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: 32px;
            height: 32px;
            padding: 0;
            color: transparent;
            background-color: transparent;
            border: none;
            cursor: pointer;
            flex-shrink: 0;
        }

        #supportBtn:hover {
            opacity: 0.8;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 20000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #2d2d2d;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            width: 80%;
            max-width: 500px;
            color: white;
            text-align: left;
            display: flex;
            flex-direction: column;
            min-height: 300px;
        }

        .modal-content h2 {
            margin-top: 0;
            color: #007bff;
        }

        .modal-content textarea {
            width: 100%;
            height: 100px;
            background-color: #1a1a1a;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            box-sizing: border-box;
            resize: vertical;
        }

        .modal-footer {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-footer button {
            padding: 8px 16px;
        }

        .confirm-btn {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .confirm-btn:hover {
            background-color: #0056b3;
        }

        .modal-body>div select,
        .modal-body>div input[type="number"] {
            width: 40%;
            padding: 8px;
            border: 1px solid #444;
            border-radius: 6px;
            background-color: #1a1a1a;
            color: white;
            font-size: 16px;
            font-family: Arial, sans-serif;
        }

        .eq-threshold-controls {
            gap: 10px;
        }

        .eq-label {
            gap: 8px;
        }

        .label-text {
            min-width: 60px;
            font-size: 14px;
        }

        .select-wrapper {
            flex: 1;
        }

        .select-wrapper select {
            width: 100%;
        }

        .eq-threshold-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .eq-label {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .label-text {
            min-width: 80px;
            color: #ccc;
            font-size: 16px;
        }

        .select-wrapper {
            flex: 1;
        }

        .select-wrapper select {
            width: 100%;
        }

        .modal-body .select-wrapper select {
            width: 100%;
        }

        #eqThresholdSelect {
            font-size: 65%;
        }

        .modal-body>div select:focus,
        .modal-body>div input[type="number"]:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        }

        .cancel-btn {
            background-color: #6c757d;
        }

        .cancel-btn:hover {
            padding-top: 10px;
            background-color: #5a6268;
        }

        /* Tabs */
        .tabs-header {
            display: flex;
            margin-bottom: 10px;
        }

        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #2d2d2d;
            color: white;
            border: 1px solid #444;
            border-bottom: none;
        }

        .tab-btn.active {
            background-color: #007bff;
        }

        .tab-content {
            display: none;
            padding: 40px 20px;
            border: 1px solid #444;
            background-color: #2d2d2d;
        }

        .tab-content.active {
            display: block;
            flex: 1;
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const gameId = urlParams.get('game_id') || 'default';
        const error = urlParams.get('error') || '0';


        // Add cache-busting to CSS background images
        document.addEventListener('DOMContentLoaded', function () {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const invertBtn = document.getElementById('invertBtn');
            const screenshotBtn = document.getElementById('screenshotBtn');
            const screenSaveBtn = document.getElementById('screenSaveBtn');
            const screenUploadBtn = document.getElementById('screenUploadBtn');
            if (prevBtn) {
                prevBtn.style.backgroundImage = "url('/static/left.png?t=" + Date.now() + "')";
            }
            if (nextBtn) {
                nextBtn.style.backgroundImage = "url('/static/right.png?t=" + Date.now() + "')";
            }
            if (invertBtn) {
                invertBtn.style.backgroundImage = "url('/static/change_color.png?t=" + Date.now() + "')";
            }
            if (screenshotBtn) {
                screenshotBtn.style.backgroundImage = "url('/static/Screen.png?t=" + Date.now() + "')";
            }
            if (screenSaveBtn) {
                screenSaveBtn.style.backgroundImage = "url('/static/ScreenSave.png?t=" + Date.now() + "')";
            }
            if (screenUploadBtn) {
                screenUploadBtn.style.backgroundImage = "url('/static/ScreenUpload.png?t=" + Date.now() + "')";
            }
            const supportBtn = document.getElementById('supportBtn');
            if (supportBtn) {
                supportBtn.style.backgroundImage = "url('/static/Screen.png?t=" + Date.now() + "')";
            }
        });
    </script>
</head>

<body>
    <div class="container">
        <h1>Backgammon Game Analysis</h1>
        <div class="header">
            <div id="match-info"></div>
            <div id="players-info"></div>
            <div id="top-bar"></div>
        </div>
        <canvas id="boardCanvas" width="800" height="800"></canvas>
        <div class="board-footer">
            <div id="move-info" class="move-info"></div>
            <div id="red-pips" class="pips-below-board">0</div>
        </div>

        <div id="top-row">
            <div id="controls">
                <div class="screenshot-controls">
                    <div>
                        <button onclick="toggleInvert()" id="invertBtn"></button>
                        <button onclick="takeScreenshot()" id="screenshotBtn"></button>
                    </div>
                    <div>
                        <button onclick="saveScreenshot()" id="screenSaveBtn"></button>
                        <button onclick="uploadScreenshots()" id="screenUploadBtn"></button>
                    </div>
                </div>
                <div class="navigation-controls">
                    <button onclick="prevTurn()" id="prevBtn"></button>
                    <span id="turnLabel">0</span>
                    <button onclick="nextTurn()" id="nextBtn"></button>
                </div>
            </div>
        </div>

        <div class="hints-table">
            <div class="hints-buttons">
                <button id="moveHintsBtn" class="hint-toggle-btn">Ход</button>
                <button id="cubeHintsBtn" class="hint-toggle-btn">Куб</button>
            </div>
            <div id="moveHintsTable" class="hints-content"></div>
            <div id="cubeHintsTable" class="hints-content"></div>
        </div>

        <!-- animation-controls перенесены в модальное окно настроек -->

        <div style="display: flex; align-items: center; justify-content: space-between; margin: 20px 0 10px 0;">
            <div class="settings-container" style="margin: 0;">
                <button id="settingsBtn" onclick="openSettingsModal()" title="Настройки">⚙️</button>
                <span>Настройки</span>
            </div>
            <button onclick="openPokazEditor()" style="
                padding: 10px 20px;
                background-color: #007bff;
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                transition: background-color 0.3s;
            " onmouseover="this.style.backgroundColor='#0056b3'" onmouseout="this.style.backgroundColor='#007bff'">
                Открыть редактор
            </button>
        </div>
        <div class="support-container">
            <button id="supportBtn" onclick="openSupportModal()" title="Техподержка"></button>
            <span>Отправить скрин в тех поддержку</span>
        </div>

        <div id="supportModal" class="modal">
            <div class="modal-content">
                <h2>Техническая поддержка</h2>
                <p>Опишите проблему, с которой вы столкнулись:</p>
                <textarea id="supportText" placeholder="Введите текст сообщения..."></textarea>
                <div class="modal-footer">
                    <button class="cancel-btn" onclick="closeSupportModal()">Отмена</button>
                    <button id="sendSupportBtn" onclick="sendToSupport()">Отправить</button>
                </div>
            </div>
        </div>

        <!-- Модальное окно настроек -->
        <div id="settingsModal" class="modal settings-modal">
            <div class="modal-content settings-modal-content">
                <div class="modal-body">
                    <div class="tabs-container">
                        <div class="tabs-header">
                            <button class="tab-btn active"
                                onclick="switchTab('animation-controls-tab')">Анимация</button>
                            <button class="tab-btn" onclick="switchTab('eq-threshold-tab')">Порог EQ</button>
                        </div>
                        <div class="tabs-content">
                            <!-- Вкладка Animation Controls -->
                            <div id="animation-controls-tab" class="tab-content active">
                                <div class="animation-controls">
                                    <label id="skipAnimationLabel"><input type="checkbox" id="skipAnimationCheckbox">
                                        Убрать анимацию
                                        шашек</label>
                                    <label><input type="checkbox" id="hidePipsCheckbox"> Убрать отображение
                                        пипсов</label>
                                    <label id="animationSpeedLabel">Скорость анимации:
                                        <select id="animationSpeedSlider">
                                            <option value="0.4">0.4</option>
                                            <option value="0.7">0.7</option>
                                            <option value="1.0" selected>1.0</option>
                                            <option value="1.3">1.3</option>
                                            <option value="1.6">1.6</option>
                                        </select>
                                    </label>
                                </div>
                            </div>
                            <!-- Вкладка EQ Threshold -->
                            <div id="eq-threshold-tab" class="tab-content">
                                <div class="eq-threshold-controls">
                                    <label class="eq-label">
                                        <span class="label-text">Порог:</span>
                                        <div class="select-wrapper">
                                            <select id="eqThresholdSelect">
                                                <option value="0.030" selected>Сомнительный ход (0.030)</option>
                                                <option value="0.060">Плохой ход (0.060)</option>
                                                <option value="0.120">Очень плохой ход (0.120)</option>
                                            </select>
                                        </div>
                                    </label>
                                    <label class="eq-label">
                                        <span class="label-text">Значение:</span>
                                        <input type="number" id="eqThreshold" step="0.001" min="0" value="0.030">
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="confirm-btn" onclick="closeSettingsModal()">Подтвердить</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        if (window.Telegram) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
        }

        let data = [];
        let dataLoaded = false;
        let redPlayer = 'Unknown';
        let blackPlayer = 'Unknown';
        let invertColors = false;
        let availableGames = [];
        let currentGameNum = null;
        let matchLength = 0;
        let gameRedScore = 0;
        let gameBlackScore = 0;
        let enable_crawford_game_number = null;
        let animating = false;
        let skipAnimation = false;
        let animationSpeed = 1.0;
        let skipAnimationEnabled = false;
        let pendingPrevGame = false;
        let hidePipsCheckbox = null;
        let hasErrorsInMatch = false;
        let eqThreshold = 0.030;
        // Load eqThreshold from localStorage if available
        const savedEqThreshold = localStorage.getItem('eqThreshold');
        if (savedEqThreshold !== null) {
            eqThreshold = parseFloat(savedEqThreshold);
        }
        const infoDiv = document.getElementById('move-info');
        const matchInfoDiv = document.getElementById('match-info');
        const playersInfoDiv = document.getElementById('players-info');
        const topBar = document.getElementById('top-bar');
        infoDiv.innerHTML = '<div class="loading">Loading game data...</div>';

        // Загружаем список доступных игр
        fetch(`/api/analysis/${gameId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(json => {
                const gameInfo = json.game_info;
                availableGames = json.games || [];
                redPlayer = gameInfo.red_player || 'Unknown';
                blackPlayer = gameInfo.black_player || 'Unknown';
                invertColors = gameInfo.invert_colors || false;
                matchLength = gameInfo.match_length || 0;
                enable_crawford_game_number = parseInt(gameInfo.enable_crawford_game) || null;
                console.log('enable_crawford_game_number:', enable_crawford_game_number)
                const scores = gameInfo.scores || {};
                const redScore = scores.Red || 0;
                const blackScore = scores.Black || 0;
                chatId = gameInfo.chat_id || chatId;
                hasErrorsInMatch = false;

                // Создаем выпадающий список для выбора игры только если это матч
                if (availableGames.length > 0 && matchLength > 0) {
                    let selectHtml = '<select id="gameSelect" class="game-select" onchange="loadGame(this.value)">';
                    selectHtml += '<option value="">Выберите игру</option>';
                    availableGames.forEach(game => {
                        selectHtml += `<option value="${game.game_number}">Игра ${game.game_number}</option>`;
                    });
                    selectHtml += '</select>';
                    currentGameNum = parseInt(availableGames[0].game_number);
                    gameRedScore = scores.Red || 0;
                    gameBlackScore = scores.Black || 0;
                    matchInfoDiv.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center;"><span>Матч до ${matchLength}</span><span>Игра ${currentGameNum}</span><span>Счет: ${gameRedScore} - ${gameBlackScore}</span></div>`;
                    playersInfoDiv.innerHTML = `Белые: ${redPlayer} – Черные: ${blackPlayer}<br>`;
                    let crawfordVisibility = (enable_crawford_game_number && currentGameNum === enable_crawford_game_number) ? 'visible' : 'hidden';
                    console.log('currentGameNum:', currentGameNum, 'enable_crawford_game_number:', enable_crawford_game_number, 'crawfordVisibility:', crawfordVisibility);
                    topBar.innerHTML = '<span id="crawfordLabel" style="visibility: ' + crawfordVisibility + ';">Кроуфорд</span>' + selectHtml + '<div class="right-group"><input type="checkbox" id="hideInfoCheckbox"><div id="black-pips" class="pips-above-board">0</div></div>';

                    const hideInfoCheckbox = document.getElementById('hideInfoCheckbox');
                    if (hideInfoCheckbox) {
                        const savedState = localStorage.getItem('hideInfoCheckbox');
                        if (savedState === 'true') {
                            hideInfoCheckbox.checked = true;
                        }
                        hideInfoCheckbox.addEventListener('change', () => {
                            localStorage.setItem('hideInfoCheckbox', hideInfoCheckbox.checked);
                        });
                    }

                    // Автоматически загружаем первую игру
                    if (availableGames.length > 0) {
                        loadGame(availableGames[0].game_number);
                    }
                } else if (availableGames.length > 0) {
                    matchInfoDiv.innerHTML = "Манигейм";
                    playersInfoDiv.innerHTML = `Белые: ${redPlayer} – Черные: ${blackPlayer}<br>`;
                    topBar.innerHTML = '<span id="crawfordLabel" style="visibility: hidden;"></span>' + '<input type="checkbox" id="hideInfoCheckbox">' + '<div id="black-pips" class="pips-above-board">0</div>';

                    const hideInfoCheckbox = document.getElementById('hideInfoCheckbox');
                    if (hideInfoCheckbox) {
                        const savedState = localStorage.getItem('hideInfoCheckbox');
                        if (savedState === 'true') {
                            hideInfoCheckbox.checked = true;
                        }
                        hideInfoCheckbox.addEventListener('change', () => {
                            localStorage.setItem('hideInfoCheckbox', hideInfoCheckbox.checked);
                        });
                    }

                    // Автоматически загружаем единственную игру
                    loadGame(availableGames[0].game_number);
                } else {
                    matchInfoDiv.innerHTML = "";
                    playersInfoDiv.innerHTML = "";
                    topBar.innerHTML = '<span id="crawfordLabel" style="visibility: hidden;"></span>' + '<input type="checkbox" id="hideInfoCheckbox">' + '<div id="black-pips" class="pips-above-board">0</div>';

                    const hideInfoCheckbox = document.getElementById('hideInfoCheckbox');
                    if (hideInfoCheckbox) {
                        const savedState = localStorage.getItem('hideInfoCheckbox');
                        if (savedState === 'true') {
                            hideInfoCheckbox.checked = true;
                        }
                        hideInfoCheckbox.addEventListener('change', () => {
                            localStorage.setItem('hideInfoCheckbox', hideInfoCheckbox.checked);
                        });
                    }

                    infoDiv.innerHTML = '<div class="error">No games found in this analysis.</div>';
                }
            })
            .catch(error => {
                console.error('Error loading games list:', error);
                infoDiv.innerHTML = '<div class="error">Error loading game data. Please check the game ID and try again.</div>';
            });

        function loadGame(gameNum) {
            return new Promise((resolve, reject) => {
                if (!gameNum) {
                    data = [];
                    dataLoaded = false;
                    infoDiv.innerHTML = '<div class="loading">Select a game to view</div>';
                    document.getElementById('moveHintsTable').innerHTML = '';
                    document.getElementById('cubeHintsTable').innerHTML = '';
                    resolve();
                    return;
                }

                currentGameNum = parseInt(gameNum);
                // Update the select dropdown
                const gameSelect = document.getElementById('gameSelect');
                if (gameSelect) {
                    gameSelect.value = gameNum;
                }
                infoDiv.innerHTML = '<div class="loading">Loading game data...</div>';

                fetch(`/api/analysis/${gameId}?game_num=${gameNum}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(json => {
                        const gameInfo = json.game_info;

                        data = json.moves.filter(item => item.turn !== undefined || item.action === 'win');
                        data = data.filter(it => ((Array.isArray(it.moves)) || it.action === 'win' || it.action === 'double' || it.action === 'take') && it.action !== 'pass');

                        // Сбросить current при загрузке новой игры
                        current = 0;
                        dataLoaded = true;

                        // Добавьте поле is_visible
                        data.forEach(item => {
                            if (item.hints && item.hints.length > 0) {
                                const firstEq = item.hints[0].eq;
                                const madeHint = item.hints.find(h => h.move && h.move.replace(/\*/g, '') === item.gnu_move.trim().replace(/\*/g, ''));
                                if (madeHint) {
                                    const diff = firstEq - madeHint.eq;
                                    item.is_error = diff >= eqThreshold;
                                } else {
                                    item.is_error = false;
                                }
                            } else {
                                item.is_error = false;
                            }
                            item.is_visible = (error === '0') ||
                                (error === '1' && !item.is_best_move && (Array.isArray(item.moves) && item.moves.length > 0 || item.action === 'win' || item.action === 'double' || item.action === 'take') && item.is_error) ||
                                (error === '2' && ((item.player_name === redPlayer && !item.is_best_move && (Array.isArray(item.moves) && item.moves.length > 0 || item.action === 'win' || item.action === 'double' || item.action === 'take')) || item.action === 'win') && item.is_error) ||
                                (error === '3' && ((item.player_name === blackPlayer && !item.is_best_move && (Array.isArray(item.moves) && item.moves.length > 0 || item.action === 'win' || item.action === 'double' || item.action === 'take')) || item.action === 'win') && item.is_error);
                        });

                        // Проверить, есть ли видимые ходы помимо win
                        const hasNonWinVisible = data.some(item => item.is_visible && item.action !== 'win');
                        if (hasNonWinVisible) {
                            hasErrorsInMatch = true;
                        } else if (error !== '0') {
                            // Автоматически перейти к следующей игре
                            const nextGame = availableGames.find(g => g.game_number > currentGameNum);
                            if (nextGame) {
                                loadGame(nextGame.game_number);
                            } else {
                                // Конец матча, проверить, были ли ошибки в матче
                                if (!hasErrorsInMatch) {
                                    alert('В матче нет ошибок');
                                }
                            }
                        }


                        const gameScores = gameInfo.scores || {};
                        gameRedScore = gameScores.Red || 0;
                        gameBlackScore = gameScores.Black || 0;
                        if (matchLength === 0) {
                            playersInfoDiv.innerHTML = "Белые: " + redPlayer + " – Черные: " + blackPlayer + "<br>";
                        } else {
                            matchInfoDiv.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center;"><span>Матч до ${matchLength}</span><span>Игра ${currentGameNum}</span><span>Счет: ${gameRedScore} - ${gameBlackScore}</span></div>`;
                            playersInfoDiv.innerHTML = `Белые: ${redPlayer} – Черные: ${blackPlayer}<br>`;
                        }
                        let crawfordVisibility = (enable_crawford_game_number && currentGameNum === enable_crawford_game_number) ? 'visible' : 'hidden';
                        console.log('loadGame currentGameNum:', currentGameNum, 'enable_crawford_game_number:', enable_crawford_game_number, 'crawfordVisibility:', crawfordVisibility);
                        topBar.innerHTML = '<span id="crawfordLabel" style="visibility: ' + crawfordVisibility + ';">Кроуфорд</span>' + (document.getElementById('gameSelect') ? document.getElementById('gameSelect').outerHTML : '') + '<div class="right-group">' + (document.getElementById('hideInfoCheckbox') ? document.getElementById('hideInfoCheckbox').outerHTML : '') + '<div id="black-pips" class="pips-above-board">0</div></div>';

                        const hideInfoCheckbox = document.getElementById('hideInfoCheckbox');
                        if (hideInfoCheckbox) {
                            const savedState = localStorage.getItem('hideInfoCheckbox');
                            if (savedState === 'true') {
                                hideInfoCheckbox.checked = true;
                            }
                            hideInfoCheckbox.addEventListener('change', () => {
                                localStorage.setItem('hideInfoCheckbox', hideInfoCheckbox.checked);
                            });
                        }

                        hidePipsCheckbox = document.getElementById('hidePipsCheckbox');
                        if (hidePipsCheckbox) {
                            const savedState = localStorage.getItem('hidePipsCheckbox');
                            if (savedState === 'true') {
                                hidePipsCheckbox.checked = true;
                            }
                            hidePipsCheckbox.addEventListener('change', () => {
                                localStorage.setItem('hidePipsCheckbox', hidePipsCheckbox.checked);
                                render(current, invertColors);
                            });
                        }

                        // Инициализация настроек из localStorage для модального окна
                        const initSettingsFromLocalStorage = () => {
                            const skipAnimState = localStorage.getItem('skipAnimationCheckbox');
                            const skipAnimCheckbox = document.getElementById('skipAnimationCheckbox');
                            if (skipAnimCheckbox && skipAnimState === 'true') {
                                skipAnimCheckbox.checked = true;
                            }

                            const hidePipsState = localStorage.getItem('hidePipsCheckbox');
                            if (hidePipsCheckbox && hidePipsState === 'true') {
                                hidePipsCheckbox.checked = true;
                            }

                            const animSpeedState = localStorage.getItem('animationSpeedSlider');
                            const animSpeedSlider = document.getElementById('animationSpeedSlider');
                            if (animSpeedSlider && animSpeedState) {
                                animSpeedSlider.value = animSpeedState;
                            }

                            const eqState = localStorage.getItem('eqThreshold');
                            const eqInput = document.getElementById('eqThreshold');
                            if (eqState) {
                                eqThreshold = parseFloat(eqState);
                            } else {
                                localStorage.setItem('eqThreshold', eqThreshold);
                            }
                            if (eqInput) {
                                eqInput.value = eqThreshold;
                            }

                            const eqSelect = document.getElementById('eqThresholdSelect');
                            if (eqSelect) {
                                eqSelect.value = eqThreshold.toString();
                            }

                            // Hide animation controls in error mode
                            if (error !== '0') {
                                const skipLabel = document.getElementById('skipAnimationLabel');
                                if (skipLabel) skipLabel.style.display = 'none';
                                const speedLabel = document.getElementById('animationSpeedLabel');
                                if (speedLabel) speedLabel.style.display = 'none';
                            }
                        };

                        // Инициализируем настройки при загрузке игры
                        initSettingsFromLocalStorage();
                        updateVisibility();

                        // Обработчики изменения для порогов EQ
                        const eqInput = document.getElementById('eqThreshold');
                        if (eqInput) {
                            eqInput.addEventListener('input', (e) => {
                                eqThreshold = parseFloat(e.target.value) || 0.060;
                                localStorage.setItem('eqThreshold', eqThreshold);
                                const eqSelect = document.getElementById('eqThresholdSelect');
                                if (eqSelect) {
                                    eqSelect.value = eqThreshold.toString();
                                }
                                updateVisibility();
                            });
                        }

                        const eqSelect = document.getElementById('eqThresholdSelect');
                        if (eqSelect) {
                            eqSelect.addEventListener('change', (e) => {
                                const value = parseFloat(e.target.value);
                                eqThreshold = value;
                                localStorage.setItem('eqThreshold', eqThreshold);
                                const eqInput = document.getElementById('eqThreshold');
                                if (eqInput) {
                                    eqInput.value = value;
                                }
                                updateVisibility();
                            });
                        }

                        const skipAnimationCheckbox = document.getElementById('skipAnimationCheckbox');
                        if (skipAnimationCheckbox) {
                            skipAnimationCheckbox.addEventListener('change', (e) => {
                                skipAnimationEnabled = e.target.checked;
                                localStorage.setItem('skipAnimationCheckbox', e.target.checked);
                            });
                        }

                        // Force skip animation if error != '0'
                        if (error !== '0') {
                            skipAnimationEnabled = true;
                        }

                        const animationSpeedSlider = document.getElementById('animationSpeedSlider');
                        if (animationSpeedSlider) {
                            animationSpeedSlider.addEventListener('change', (e) => {
                                animationSpeed = parseFloat(e.target.value);
                                localStorage.setItem('animationSpeedSlider', e.target.value);
                            });
                        }

                        // Найти все индексы ходов с удвоением
                        doubleTurns = data.map((item, index) => item.action === 'double' ? index : -1).filter(idx => idx !== -1);
                        firstDoubleIndex = doubleTurns.length > 0 ? doubleTurns[0] : -1;

                        if (data.length > 0) {
                            dataLoaded = true;
                            console.log('Data loaded:', data);
                            console.log('First turn data:', data[0]);
                            console.log('First turn moves:', data[0]?.moves);
                            current = 0;
                            if (data[0]?.action === 'skip') {
                                current = 1;
                            }
                            // Найти первый видимый ход
                            while (current < data.length && !data[current].is_visible) {
                                current++;
                            }
                            if (current >= data.length) {
                                current = 0; // fallback
                            }
                            // Reset hints display
                            moveHintsTable.classList.remove('active');
                            cubeHintsTable.classList.remove('active');
                            moveHintsBtn.classList.remove('active');
                            cubeHintsBtn.classList.remove('active');
                            if (imagesLoaded === 27) {
                                render(current, invertColors);
                                updateButtons();
                                infoDiv.innerHTML = '';
                                // Auto-select move hints
                                moveHintsTable.classList.add('active');
                                moveHintsBtn.classList.add('active');
                            } else {
                                console.log('Waiting for images to load before rendering');
                            }
                        } else {
                            infoDiv.innerHTML = '<div class="error">No game data found for this game.</div>';
                        }
                        resolve();
                    })
                    .catch(error => {
                        console.error('Error loading game:', error);
                        infoDiv.innerHTML = '<div class="error">Error loading game data. Please try again.</div>';
                        reject(error);
                    });
            });
        }

        let current = 0;
        let doubleTurns = [];
        let firstDoubleIndex = -1;
        let currentCube = null;
        let currentCubePlayer = null;

        function updateVisibility() {
            if (!dataLoaded || !data || data.length === 0) return;
            data.forEach(item => {
                if (item.hints && item.hints.length > 0) {
                    const firstEq = item.hints[0].eq;
                    const madeHint = item.hints.find(h => h.move && h.move.replace(/\*/g, '') === item.gnu_move.trim().replace(/\*/g, ''));
                    if (madeHint) {
                        const diff = firstEq - madeHint.eq;
                        item.is_error = diff >= eqThreshold;
                    } else {
                        item.is_error = false;
                    }
                } else {
                    item.is_error = false;
                }
                item.is_visible = (error === '0') ||
                    (error === '1' && !item.is_best_move && (Array.isArray(item.moves) && item.moves.length > 0 || item.action === 'win' || item.action === 'double' || item.action === 'take') && item.is_error) ||
                    (error === '2' && ((item.player_name === redPlayer && !item.is_best_move && (Array.isArray(item.moves) && item.moves.length > 0 || item.action === 'win' || item.action === 'double' || item.action === 'take')) || item.action === 'win') && item.is_error) ||
                    (error === '3' && ((item.player_name === blackPlayer && !item.is_best_move && (Array.isArray(item.moves) && item.moves.length > 0 || item.action === 'win' || item.action === 'double' || item.action === 'take')) || item.action === 'win') && item.is_error);
            });
            // Проверить границы перед обращением к data[current]
            if (current < 0 || current >= data.length) {
                current = 0;
            }
            // Найти новый current, если текущий не видим
            if (data[current] && !data[current].is_visible) {
                let newCurrent = current;
                while (newCurrent >= 0 && newCurrent < data.length && !data[newCurrent].is_visible) newCurrent--;
                if (newCurrent < 0) {
                    newCurrent = current;
                    while (newCurrent < data.length && !data[newCurrent].is_visible) newCurrent++;
                }
                if (newCurrent >= data.length) newCurrent = data.length - 1;
                if (newCurrent < 0) newCurrent = 0;
                current = newCurrent;
            }
            render(current, invertColors);
            updateButtons();
        }

        function updateCurrentCube(turn) {
            let lastDoubleIndex = -1;
            for (let i = 0; i < doubleTurns.length; i++) {
                if (doubleTurns[i] <= turn) {
                    lastDoubleIndex = doubleTurns[i];
                } else {
                    break;
                }
            }
            if (lastDoubleIndex !== -1) {
                const cubeValue = data[lastDoubleIndex].cube;
                const doubleImages = {
                    2: Double2,
                    4: Double4,
                    8: Double8,
                    16: Double16,
                    32: Double32,
                    64: Double64
                };
                currentCube = doubleImages[cubeValue];
                currentCubePlayer = data[lastDoubleIndex].player;
            } else {
                currentCube = null;
                currentCubePlayer = null;
            }
        }
        const canvas = document.getElementById('boardCanvas');
        const ctx = canvas.getContext('2d');

        const moveHintsBtn = document.getElementById('moveHintsBtn');
        const cubeHintsBtn = document.getElementById('cubeHintsBtn');
        const moveHintsTable = document.getElementById('moveHintsTable');
        const cubeHintsTable = document.getElementById('cubeHintsTable');

        // Default to move hints active
        moveHintsBtn.classList.add('active');
        moveHintsTable.classList.add('active');

        moveHintsBtn.addEventListener('click', () => {
            moveHintsTable.classList.add('active');
            cubeHintsTable.classList.remove('active');
            moveHintsBtn.classList.add('active');
            cubeHintsBtn.classList.remove('active');
        });

        cubeHintsBtn.addEventListener('click', () => {
            cubeHintsTable.classList.add('active');
            moveHintsTable.classList.remove('active');
            cubeHintsBtn.classList.add('active');
            moveHintsBtn.classList.remove('active');
        });

        const boardImg = new Image();
        boardImg.src = '/static/board.png?t=' + Date.now();

        const blackImg = new Image();
        blackImg.src = '/static/black_checker.png?t=' + Date.now();

        const whiteImg = new Image();
        whiteImg.src = '/static/white_checker.png?t=' + Date.now();

        const Dice1w = new Image();
        Dice1w.src = '/static/1w.png?t=' + Date.now();
        const Dice2w = new Image();
        Dice2w.src = '/static/2w.png?t=' + Date.now();
        const Dice3w = new Image();
        Dice3w.src = '/static/3w.png?t=' + Date.now();
        const Dice4w = new Image();
        Dice4w.src = '/static/4w.png?t=' + Date.now();
        const Dice5w = new Image();
        Dice5w.src = '/static/5w.png?t=' + Date.now();
        const Dice6w = new Image();
        Dice6w.src = '/static/6w.png?t=' + Date.now();

        const Dice1b = new Image();
        Dice1b.src = '/static/1b.png?t=' + Date.now();
        const Dice2b = new Image();
        Dice2b.src = '/static/2b.png?t=' + Date.now();
        const Dice3b = new Image();
        Dice3b.src = '/static/3b.png?t=' + Date.now();
        const Dice4b = new Image();
        Dice4b.src = '/static/4b.png?t=' + Date.now();
        const Dice5b = new Image();
        Dice5b.src = '/static/5b.png?t=' + Date.now();
        const Dice6b = new Image();
        Dice6b.src = '/static/6b.png?t=' + Date.now();

        const Double2 = new Image();
        Double2.src = '/static/Double2.png?t=' + Date.now();
        const Double4 = new Image();
        Double4.src = '/static/Double4.png?t=' + Date.now();
        const Double8 = new Image();
        Double8.src = '/static/Double8.png?t=' + Date.now();
        const Double16 = new Image();
        Double16.src = '/static/Double16.png?t=' + Date.now();
        const Double32 = new Image();
        Double32.src = '/static/Double32.png?t=' + Date.now();
        const Double64 = new Image();
        Double64.src = '/static/Double64.png?t=' + Date.now();

        const LeftArrow = new Image();
        LeftArrow.src = '/static/left.png?t=' + Date.now();
        const RightArrow = new Image();
        RightArrow.src = '/static/right.png?t=' + Date.now();

        const ScreenShot = new Image();
        ScreenShot.src = '/static/Screen.png?t=' + Date.now();
        const ScreenSave = new Image();
        ScreenSave.src = '/static/ScreenSave.png?t=' + Date.now();
        const ScreenUpload = new Image();
        ScreenUpload.src = '/static/ScreenUpload.png?t=' + Date.now();

        const ChangeColor = new Image();
        ChangeColor.src = '/static/change_color.png?t=' + Date.now();

        let imagesLoaded = 0;
        const checkImagesLoaded = () => {
            imagesLoaded++;
            console.log('Images loaded:', imagesLoaded);
            if (imagesLoaded === 27 && dataLoaded) {
                console.log('All images and data loaded, rendering turn', current);
                render(current, invertColors);
                updateButtons();
                infoDiv.innerHTML = '';
            }
        };

        boardImg.onload = checkImagesLoaded;
        blackImg.onload = checkImagesLoaded;
        whiteImg.onload = checkImagesLoaded;
        Dice1w.onload = checkImagesLoaded;
        Dice2w.onload = checkImagesLoaded;
        Dice3w.onload = checkImagesLoaded;
        Dice4w.onload = checkImagesLoaded;
        Dice5w.onload = checkImagesLoaded;
        Dice6w.onload = checkImagesLoaded;
        Dice1b.onload = checkImagesLoaded;
        Dice2b.onload = checkImagesLoaded;
        Dice3b.onload = checkImagesLoaded;
        Dice4b.onload = checkImagesLoaded;
        Dice5b.onload = checkImagesLoaded;
        Dice6b.onload = checkImagesLoaded;
        Double2.onload = checkImagesLoaded;
        Double4.onload = checkImagesLoaded;
        Double8.onload = checkImagesLoaded;
        Double16.onload = checkImagesLoaded;
        Double32.onload = checkImagesLoaded;
        Double64.onload = checkImagesLoaded;
        LeftArrow.onload = checkImagesLoaded;
        RightArrow.onload = checkImagesLoaded;
        ScreenShot.onload = checkImagesLoaded;
        ScreenSave.onload = checkImagesLoaded;
        ScreenUpload.onload = checkImagesLoaded;
        ChangeColor.onload = checkImagesLoaded;

        // Обработка ошибок загрузки изображений
        [boardImg, blackImg, whiteImg, Dice1w, Dice2w, Dice3w, Dice4w, Dice5w, Dice6w, Dice1b, Dice2b, Dice3b, Dice4b, Dice5b, Dice6b, Double2, Double4, Double8, Double16, Double32, Double64, LeftArrow, RightArrow, ScreenShot, ChangeColor, ScreenSave, ScreenUpload,].forEach(img => {
            img.onerror = () => {
                console.error(`Failed to load image: ${img.src}`);
                infoDiv.innerHTML = '<div class="error">Error loading game assets. Please try again later.</div>';
            };
        });

        const diceImages = {
            white: {
                1: Dice1w,
                2: Dice2w,
                3: Dice3w,
                4: Dice4w,
                5: Dice5w,
                6: Dice6w
            },
            black: {
                1: Dice1b,
                2: Dice2b,
                3: Dice3b,
                4: Dice4b,
                5: Dice5b,
                6: Dice6b
            }
        };

        const cubeImages = {
            2: Double2,
            4: Double4,
            8: Double8,
            16: Double16,
            32: Double32,
            64: Double64
        };

        function getX(point) {
            if (point >= 13 && point <= 18) {
                const baseX = 50 + (point - 13) * 60;
                return baseX - (point === 13 ? 8 : 0);
            } else if (point >= 19 && point <= 24) {
                return 450 + (point - 19) * 60;
            } else if (point >= 7 && point <= 12) {
                const baseX = 50 + (12 - point) * 60;
                return baseX - (point === 12 ? 4 : 0);
            } else if (point >= 1 && point <= 6) {
                return 450 + (6 - point) * 60;
            }
            return 0;
        }

        function getBaseY(point) {
            return (point > 12) ? 70 : 690;
        }

        function getDy(point) {
            return (point > 12) ? 55 : -55;
        }

        function calculatePips(positions, player, invertColors = false) {
            let totalPips = 0;
            for (let pointStr in positions) {
                if (pointStr === 'bar') {
                    totalPips += Math.abs(positions[pointStr]) * 25;
                } else if (pointStr === 'off') {
                } else {
                    const point = parseInt(pointStr);
                    const count = positions[pointStr];
                    let effectivePoint = point;
                    if (invertColors) {
                        if (player === 'red') {
                            effectivePoint = 25 - point;
                        } else if (player === 'black') {
                            effectivePoint = point;
                        }
                    } else {
                        if (player === 'black') {
                            effectivePoint = 25 - point;
                        } else {
                            effectivePoint = point;
                        }
                    }
                    totalPips += count * effectivePoint;
                }
            }
            return totalPips;
        }

        function currentPlayerType(positions, currentPlayerType) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(boardImg, 0, 0, canvas.width, canvas.height);

            drawCheckers('red', whiteImg, positions.red, currentPlayerType);
            drawCheckers('black', blackImg, positions.black, currentPlayerType);

            const turnData = data[current];
            if (turnData && turnData.dice && turnData.dice.length >= 2 && !['double', 'take', 'win'].includes(turnData.action)) {
                const [d1, d2] = turnData.dice;
                const diceY = 350;
                let diceX1, diceX2;
                let diceSet;
                if (invertColors) {
                    if (currentPlayer === 'red') {
                        diceX1 = 130;
                        diceX2 = 220;
                        diceSet = diceImages.white;
                    } else {
                        diceX1 = 530;
                        diceX2 = 620;
                        diceSet = diceImages.black;
                    }
                } else {
                    if (currentPlayer === 'red') {
                        diceX1 = 530;
                        diceX2 = 620;
                        diceSet = diceImages.white;
                    } else {
                        diceX1 = 130;
                        diceX2 = 220;
                        diceSet = diceImages.black;
                    }
                }
                if (diceSet[d1]) ctx.drawImage(diceSet[d1], diceX1, diceY, 60, 60);
                if (diceSet[d2]) ctx.drawImage(diceSet[d2], diceX2, diceY, 60, 60);
            }

            // Draw cube during animation
            const item = turnData;
            if (current < firstDoubleIndex) {
                ctx.drawImage(Double64, 375, 350, 50, 50);
            }

            for (let i = 0; i < doubleTurns.length; i++) {
                const doubleIndex = doubleTurns[i];
                if (current === doubleIndex) {
                    const cubeValue = data[doubleIndex].cube;
                    const doubleImages = {
                        2: Double2,
                        4: Double4,
                        8: Double8,
                        16: Double16,
                        32: Double32,
                        64: Double64
                    };
                    const img = doubleImages[cubeValue];
                    if (img) {
                        let cubeX;
                        if (invertColors) {
                            if (data[doubleIndex].player === 'Red') {
                                cubeX = 175; // куб справа для красных при инверсии
                            } else {
                                cubeX = 575; // куб слева для черных при инверсии
                            }
                        } else {
                            if (data[doubleIndex].player === 'Red') {
                                cubeX = 575; // куб слева для красных
                            } else {
                                cubeX = 175; // куб справа для черных
                            }
                        }
                        ctx.drawImage(img, cubeX, 350, 50, 50);
                    }
                    break;
                }
            }

            if (currentCube && current > firstDoubleIndex && !doubleTurns.includes(current) && item.action !== 'win') {
                let cubeY = 350;
                if (invertColors) {
                    if (currentCubePlayer === 'Red') {
                        cubeY = 600;
                    } else if (currentCubePlayer === 'Black') {
                        cubeY = 100;
                    }
                } else {
                    if (currentCubePlayer === 'Black') {
                        cubeY = 600;
                    } else if (currentCubePlayer === 'Red') {
                        cubeY = 100;
                    }
                }
                ctx.drawImage(currentCube, 375, cubeY, 50, 50);
            }

            if (item.action === 'win') {
                ctx.drawImage(Double64, 375, 350, 50, 50);
            }
        }

        function animateSingleMove(move, playerType, temp_positions, callback) {
            const img = playerType === 'red' ? whiteImg : blackImg;
            const player_pos = temp_positions[playerType];
            const opp_pos = temp_positions[playerType === 'red' ? 'black' : 'red'];
            const fromStr = move.from.toString();
            const toStr = move.to.toString()
            let fromX, fromY;
            const rawFrom = move.from;
            const fromIsBar = (rawFrom === 'bar' || rawFrom === 25 || rawFrom === '25');
            const rawTo = move.to;
            const isOff = (rawTo === 'off' || rawTo === 0 || rawTo === '0');
            const isBar = (rawTo === 'bar' || rawTo === 25 || rawTo === '25');
            if (fromIsBar) {
                fromX = 400;
                let barY = (playerType === 'black') ? 220 : 520;
                let barDy = (playerType === 'black') ? 55 : -55;
                if (invertColors) {
                    barY = (playerType === 'black') ? 520 : 220;
                    barDy = (playerType === 'black') ? -55 : 55;
                }
                const barCount = player_pos['bar'] || 0;
                fromY = barY + (barCount - 1) * barDy;
            } else {
                const fromPoint = parseInt(fromStr);
                fromX = getX(fromPoint);
                const fromBaseY = getBaseY(fromPoint);
                const fromDy = getDy(fromPoint);
                const fromCount = player_pos[fromStr] || 0;
                fromY = fromBaseY + (fromCount - 1) * fromDy;
            }

            if (fromIsBar) {
                player_pos['bar'] = (player_pos['bar'] || 1) - 1;
                if (player_pos['bar'] === 0) delete player_pos['bar'];
            } else {
                player_pos[fromStr] = (player_pos[fromStr] || 1) - 1;
                if (player_pos[fromStr] === 0) delete player_pos[fromStr];
            }

            let toX, toY;
            if (isOff) {
                toX = 820;
                toY = playerType === 'black'
                    ? (invertColors ? 440 : 340)
                    : (invertColors ? 340 : 440);
            } else {
                const toPoint = parseInt(toStr);
                toX = getX(toPoint);
                const toBaseY = getBaseY(toPoint);
                const toDy = getDy(toPoint);
                let toCount = player_pos[toStr] || 0;
                if (move.hit) {
                    toCount = 0; // After hit, place on empty point
                }
                toY = toBaseY + toCount * toDy;
            }

            let progress = 0;
            const duration = 200 / animationSpeed; // Duration for smooth animation
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);
                // Ease-in-out for smoother movement
                const easedProgress = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                const currentX = fromX + (toX - fromX) * easedProgress;
                const currentY = fromY + (toY - fromY) * easedProgress;

                drawBoardForAnimation(temp_positions);
                ctx.drawImage(img, currentX - 31.25, currentY - 31.25, 62.5, 62.5);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Add checker to to position
                    if (toStr === 'off') {
                        player_pos['off'] = (player_pos['off'] || 0) + 1;
                    } else {
                        player_pos[toStr] = (player_pos[toStr] || 0) + 1;
                    }
                    callback(move.hit, move, playerType, temp_positions);
                }
            };
            animate();
        }

        function animateHit(move, playerType, temp_positions, finalCallback) {
            const hitPlayerType = playerType === 'red' ? 'black' : 'red';
            const img = hitPlayerType === 'red' ? whiteImg : blackImg;
            const opp_pos = temp_positions[hitPlayerType];

            const toStr = move.to.toString();
            // Temporarily remove hit checker from to position
            opp_pos[toStr] = (opp_pos[toStr] || 1) - 1;
            if (opp_pos[toStr] === 0) delete opp_pos[toStr];

            const hitPoint = parseInt(toStr);
            const fromX = getX(hitPoint);
            const fromBaseY = getBaseY(hitPoint);
            const fromDy = getDy(hitPoint);
            const hitCount = opp_pos[toStr] || 0; // Now 0
            let fromY = fromBaseY + (hitCount - 1) * fromDy;

            const barX = 400;
            let barY = (hitPlayerType === 'black') ? 220 : 520;
            let barDy = (hitPlayerType === 'black') ? 55 : -55;
            if (invertColors) {
                barY = (hitPlayerType === 'black') ? 520 : 220;
                barDy = (hitPlayerType === 'black') ? -55 : 55;
            }
            const barCount = opp_pos['bar'] || 0;
            const toX = 820; // Fly to the right
            const toY = barY + barCount * barDy; // Position for the hit checker on bar

            let progress = 0;
            const duration = 200 / animationSpeed;
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);
                // Ease-in-out for smoother movement
                const easedProgress = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                const currentX = fromX + (barX - fromX) * easedProgress;
                const currentY = fromY + (toY - fromY) * easedProgress;

                drawBoardForAnimation(temp_positions);
                ctx.drawImage(img, currentX - 31.25, currentY - 31.25, 62.5, 62.5);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Add hit checker to bar
                    opp_pos['bar'] = (opp_pos['bar'] || 0) + 1;
                    finalCallback();
                }
            };
            animate();
        }

        function updateTempPositionsAfterMove(move, playerType, temp_positions) {
            const player_pos = temp_positions[playerType];
            const opp_pos = temp_positions[playerType === 'red' ? 'black' : 'red'];
            const fromStr = move.from.toString();
            const toStr = move.to.toString();
            const isOffMove = (move.to === 0 || move.to === '0' || move.to === 'off');
            const isBarFrom = (move.from === 25 || move.from === '25' || move.from === 'bar');
            if (move.hit) {
                opp_pos[toStr] = (opp_pos[toStr] || 1) - 1;
                if (opp_pos[toStr] === 0) delete opp_pos[toStr];
                opp_pos['bar'] = (opp_pos['bar'] || 0) + 1;
            }

            if (isBarFrom) {
                player_pos['bar'] = (player_pos['bar'] || 1) - 1;
                if (player_pos['bar'] <= 0) delete player_pos['bar'];
            } else {
                player_pos[fromStr] = (player_pos[fromStr] || 1) - 1;
                if (player_pos[fromStr] === 0) delete player_pos[fromStr];
            }
            if (isOffMove) {
                player_pos['off'] = (player_pos['off'] || 0) + 1;
            } else {
                player_pos[toStr] = (player_pos[toStr] || 0) + 1;
            }
        }

        function drawCheckers(player, img, positions, currentPlayer) {
            ctx.font = 'bold 30px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (player === currentPlayer) {
                for (let point = 1; point <= 24; point++) {
                    const x = getX(point);
                    let y = getBaseY(point);
                    const dy = getDy(point);

                    let displayPoint = point;
                    if (invertColors) {
                        if (player === 'red') {
                            displayPoint = 25 - point; // Red sees points inverted when colors are inverted
                        } else if (player === 'black') {
                            displayPoint = point; // Black sees points normally when colors are inverted
                        }
                    } else {
                        if (player === 'black') {
                            displayPoint = 25 - point; // Black sees points inverted (24 at top-right, 1 at bottom-left)
                        } else if (player === 'red') {
                            displayPoint = point; // Red sees points starting from bottom-left (1 at bottom-left, 24 at top-right)
                        }
                    }
                    let numberY;
                    if (point > 12) {
                        numberY = y - 50; // Above for upper half
                    } else {
                        numberY = y + 60; // Below for lower half
                    }
                    ctx.fillText(displayPoint, x, numberY);
                }
            }

            for (let pointStr in positions) {
                if (pointStr === 'bar' || pointStr === 'off') continue;
                const point = parseInt(pointStr);
                let count = positions[pointStr];
                const x = getX(point);
                let y = getBaseY(point);
                const dy = getDy(point);

                for (let i = 0; i < Math.min(count, 6); i++) {
                    ctx.drawImage(img, x - 31.25, y + (i * dy) - 31.25, 62.5, 62.5);
                }

                if (count > 6) {
                    const lastCheckerY = y + (5 * dy);
                    ctx.fillText(`${count}`, x + 40, lastCheckerY + 5);
                }
            }

            const barX = 400;
            let barY = (player === 'black') ? 220 : 520;
            if (invertColors) {
                barY = (player === 'black') ? 520 : 220;
            }
            if (positions.bar && positions.bar !== 0) {
                let y = barY;
                const dy = (player === 'black') ? 55 : -55;
                for (let i = 0; i < Math.min(Math.abs(positions.bar), 6); i++) {
                    ctx.drawImage(img, barX - 31.25, y + (i * dy) - 31.25, 62.5, 62.5);
                }
                if (Math.abs(positions.bar) > 6) {
                    const lastCheckerY = y + (5 * dy);
                    ctx.fillText(`(${Math.abs(positions.bar)})`, barX + 30, lastCheckerY + 5);
                }
            }

            let offX = 783;
            // объявляем offY вне блоков, затем назначаем значение в зависимости от invertColors и player
            let offY;
            if (invertColors) {
                offY = (player === 'black') ? 440 : 340;
            } else {
                offY = (player === 'black') ? 340 : 440;
            }
            if (positions.off && positions.off !== 0) {
                const originalFont = ctx.font;
                ctx.font = 'bold 32px Arial';
                ctx.fillText(`${positions.off}`, offX, offY);
                ctx.font = originalFont;
            }
        }

        function render(turn, invertColors = false) {
            if (!data || !data[turn]) {
                console.error('No data for turn:', turn);
                document.getElementById('move-info').innerHTML = '<div class="error">No data available for this turn.</div>';
                return;
            }

            const hidePips = hidePipsCheckbox && hidePipsCheckbox.checked;

            current = turn;
            updateCurrentCube(turn);
            document.getElementById('turnLabel').innerText = `${data[turn].turn || 'End'}`;
            console.log('Rendering turn:', turn, 'Data:', data[turn]);

            ctx.clearRect(0, 0, 800, 800);
            ctx.drawImage(boardImg, 0, 0, 800, 800);

            let redPositions, blackPositions;
            if (turn === 0) {
                if (invertColors) {
                    redPositions = { '1': 2, '12': 5, '17': 3, '19': 5, 'bar': 0, 'off': 0 };
                    blackPositions = { '6': 5, '8': 3, '13': 5, '24': 2, 'bar': 0, 'off': 0 };
                } else {
                    redPositions = { '24': 2, '6': 5, '8': 3, '13': 5, 'bar': 0, 'off': 0 };
                    blackPositions = { '1': 2, '19': 5, '17': 3, '12': 5, 'bar': 0, 'off': 0 };
                }
            } else {
                const prevTurn = turn - 1;
                if (invertColors) {
                    redPositions = data[prevTurn].inverted_positions['red'];
                    blackPositions = data[prevTurn].inverted_positions['black'];
                } else {
                    redPositions = data[prevTurn].positions['red'];
                    blackPositions = data[prevTurn].positions['black'];
                }
            }
            const currentPlayer = data[turn].player.toLowerCase();
            drawCheckers('red', whiteImg, redPositions, currentPlayer);
            drawCheckers('black', blackImg, blackPositions, currentPlayer);

            const redPips = calculatePips(redPositions, 'red', invertColors);
            const blackPips = calculatePips(blackPositions, 'black', invertColors);

            if (!hidePips) {
                if (invertColors) {
                    document.getElementById('black-pips').innerText = `${redPips}`;
                    document.getElementById('red-pips').innerText = `${blackPips}`;
                    document.getElementById('black-pips').className = 'pips-above-board-inverted';
                    document.getElementById('red-pips').className = 'pips-below-board-inverted';
                    document.getElementById('black-pips').style.display = 'block';
                    document.getElementById('red-pips').style.display = 'block';
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(650, 800, 150, 50);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${redPips}`, 725, -20);

                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(650, -50, 150, 50);
                    ctx.fillStyle = '#000000';
                    ctx.fillText(`${blackPips}`, 725, 830);
                } else {
                    document.getElementById('black-pips').innerText = `${blackPips}`;
                    document.getElementById('red-pips').innerText = `${redPips}`;
                    document.getElementById('black-pips').className = 'pips-above-board';
                    document.getElementById('red-pips').className = 'pips-below-board';
                    document.getElementById('black-pips').style.display = 'block';
                    document.getElementById('red-pips').style.display = 'block';
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(650, -50, 150, 50);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${blackPips}`, 725, -20);

                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(650, 800, 150, 50);
                    ctx.fillStyle = '#000000';
                    ctx.fillText(`${redPips}`, 725, 830);
                }
            } else {
                document.getElementById('black-pips').style.display = 'none';
                document.getElementById('red-pips').style.display = 'none';
            }


            const item = data[turn];
            if (item.dice && item.dice.length >= 2 && !['double', 'take', 'win'].includes(item.action)) {
                const [d1, d2] = item.dice;
                const diceY = 350;

                let diceX1, diceX2;
                let diceSet;
                if (invertColors) {
                    if (item.player === 'Red') {
                        diceX1 = 130; // кубики слева для красных при инверсии
                        diceX2 = 220;
                        diceSet = diceImages.white;
                    } else {
                        diceX1 = 530; // кубики справа для черных при инверсии
                        diceX2 = 620;
                        diceSet = diceImages.black;
                    }
                } else {
                    if (item.player === 'Red') {
                        diceX1 = 530; // кубики справа для красных
                        diceX2 = 620;
                        diceSet = diceImages.white;
                    } else {
                        diceX1 = 130; // кубики слева для черных
                        diceX2 = 220;
                        diceSet = diceImages.black;
                    }
                }

                if (diceSet[d1]) ctx.drawImage(diceSet[d1], diceX1, diceY, 60, 60);
                if (diceSet[d2]) ctx.drawImage(diceSet[d2], diceX2, diceY, 60, 60);
            }


            if (turn < firstDoubleIndex) {
                ctx.drawImage(Double64, 375, 350, 50, 50);
            }

            for (let i = 0; i < doubleTurns.length; i++) {
                const doubleIndex = doubleTurns[i];
                if (turn === doubleIndex) {
                    const cubeValue = data[doubleIndex].cube;
                    const doubleImages = {
                        2: Double2,
                        4: Double4,
                        8: Double8,
                        16: Double16,
                        32: Double32,
                        64: Double64
                    };
                    const img = doubleImages[cubeValue];
                    if (img) {
                        let cubeX;
                        if (invertColors) {
                            if (data[doubleIndex].player === 'Red') {
                                cubeX = 175; // куб справа для красных при инверсии
                            } else {
                                cubeX = 575; // куб слева для черных при инверсии
                            }
                        } else {
                            if (data[doubleIndex].player === 'Red') {
                                cubeX = 575; // куб слева для красных
                            } else {
                                cubeX = 175; // куб справа для черных
                            }
                        }
                        ctx.drawImage(img, cubeX, 350, 50, 50);
                    }
                    break;
                }
            }

            if (currentCube && turn > firstDoubleIndex && !doubleTurns.includes(turn) && item.action !== 'win') {
                let cubeY = 350;
                if (invertColors) {
                    if (currentCubePlayer === 'Red') {
                        cubeY = 600;
                    } else if (currentCubePlayer === 'Black') {
                        cubeY = 100;
                    }
                } else {
                    if (currentCubePlayer === 'Black') {
                        cubeY = 600;
                    } else if (currentCubePlayer === 'Red') {
                        cubeY = 100;
                    }
                }
                ctx.drawImage(currentCube, 375, cubeY, 50, 50);
            }

            if (item.action === 'win') {
                ctx.drawImage(Double64, 375, 350, 50, 50);
            }
            let info = '';
            let prefix = (turn > 0 && data[turn - 1].action === 'double') ? '<strong>Take</strong>  <br>' : '';
            if (item.action === 'double') {
                info = `Double (${item.cube})`;
            } else if (item.action === 'take') {
                info = `Take`;
            } else if (item.action === 'win') {
                // Найти следующую игру для счета
                const nextGame = availableGames.find(g => g.game_number > currentGameNum);
                let finalRedScore, finalBlackScore;
                if (nextGame) {
                    // Загрузить scores из файла следующей игры
                    fetch(`/api/analysis/${gameId}?game_num=${nextGame.game_number}`)
                        .then(response => response.json())
                        .then(json => {
                            const nextScores = json.game_info.scores || {};
                            finalRedScore = nextScores.Red || 0;
                            finalBlackScore = nextScores.Black || 0;
                            const larger = Math.max(finalRedScore, finalBlackScore);
                            const smaller = Math.min(finalRedScore, finalBlackScore);
                            const winInfo = `${item.player_name} победил. Счёт ${larger} - ${smaller}`;
                            document.getElementById('move-info').innerHTML = winInfo;
                        })
                        .catch(error => {
                            console.error('Error loading next game scores:', error);
                            // Fallback to current logic
                            finalRedScore = gameRedScore;
                            finalBlackScore = gameBlackScore;
                            if (item.player_name === redPlayer) {
                                finalRedScore += item.points;
                            } else if (item.player_name === blackPlayer) {
                                finalBlackScore += item.points;
                            }
                            const larger = Math.max(finalRedScore, finalBlackScore);
                            const smaller = Math.min(finalRedScore, finalBlackScore);
                            info = `${item.player_name} победил. Счёт ${larger} - ${smaller}`;
                        });
                    return; // Exit early, info will be set asynchronously
                } else {
                    // Если следующей игры нет, используем текущую логику
                    finalRedScore = gameRedScore;
                    finalBlackScore = gameBlackScore;
                    if (item.player_name === redPlayer) {
                        finalRedScore += item.points;
                    } else if (item.player_name === blackPlayer) {
                        finalBlackScore += item.points;
                    }
                }
                const larger = Math.max(finalRedScore, finalBlackScore);
                const smaller = Math.min(finalRedScore, finalBlackScore);
                info = `${item.player_name} победил. Счёт ${larger} - ${smaller}`;
            } else if (item.moves && item.moves.length > 0) {
                info = prefix + `${item.gnu_move ? item.gnu_move.trim() : ''}`;
            } else if (item.moves && item.moves.length === 0) {
                info = prefix + `Пропуск`;
            } else {
                info = prefix + '<div class="info-text">No moves available for this turn.</div>';
                console.warn('No moves for turn:', turn, item);
            }
            setTimeout(() => {
                document.getElementById('move-info').innerHTML = info;
                console.log('Info set to:', info);
                console.log('Actual move-info div content:', document.getElementById('move-info').innerHTML);
            }, 0);

            // Generate cube hints table
            let cubeTableHtml = '<table><tr><th>Действие</th><th>Эквити</th></tr>';
            if (item.cube_hints && item.cube_hints.length > 0) {
                const bestAction = item.cube_hints[0].cubeful_equities.find(eq => eq.idx === 1);
                const bestAction1 = bestAction ? bestAction.action_1 : '';
                const bestAction2 = bestAction ? bestAction.action_2 : '';
                let nextGnuMove = (data[turn + 1] && data[turn + 1].gnu_move) ? data[turn + 1].gnu_move.trim() : 'pass';
                const noDoubleHint = (item.cube_hints[0].cubeful_equities || []).find(h => h.action_1 === 'No double');
                const PassHint = (item.cube_hints[0].cubeful_equities || []).find(h => h.action_1 === 'Double' && h.action_2 === 'pass');
                const noDoubleEq = noDoubleHint && noDoubleHint.eq ? noDoubleHint.eq : null;
                const PassHintEq = PassHint && PassHint.eq ? PassHint.eq : null;
                const firstCubeEq = item.cube_hints[0].cubeful_equities && item.cube_hints[0].cubeful_equities.length > 0 ? item.cube_hints[0].cubeful_equities[0].eq : null;
                (item.cube_hints[0].cubeful_equities || []).forEach((hint, index) => {
                    const eq = hint.eq ? hint.eq.toFixed(3) : '-';
                    const displayEq = (firstCubeEq !== null && hint.eq !== undefined && index > 0) ? (hint.eq - firstCubeEq).toFixed(3) : eq;
                    let displayAction = hint.action_1;
                    if (hint.action_2) {
                        displayAction += `, ${hint.action_2}`;
                    }
                    let rowClass = '';
                    if (item.gnu_move && item.gnu_move.trim() === 'Double' && hint.action_1 === 'Double' && hint.action_2 === nextGnuMove) {
                        if (noDoubleEq !== null && hint.eq !== undefined) {
                            if (hint.eq > noDoubleEq) {
                                rowClass = 'hint-best';
                            } else {
                                rowClass = 'hint-good';
                            }
                        }
                    } else if (item.gnu_move && item.gnu_move.trim() === 'take' && hint.action_2 === 'take') {
                        if (PassHintEq !== null && hint.eq !== undefined) {
                            if (hint.eq > PassHintEq) {
                                rowClass = 'hint-best';
                            } else {
                                rowClass = 'hint-good';
                            }
                        }
                    } else if (item.gnu_move && item.gnu_move.trim() !== 'take' && item.gnu_move.trim() !== 'Double' && hint.action_1 === 'No double') {
                        if (index === 0) {
                            rowClass = 'hint-best';
                        } else if (index === 1) {
                            rowClass = 'hint-good';
                        } else if (index === 2) {
                            rowClass = 'hint-poor';
                        }
                    }
                    cubeTableHtml += `<tr class="${rowClass}"><td>${displayAction}</td><td>${displayEq}</td></tr>`;
                });
            }
            cubeTableHtml += '</table>';
            if (item.action !== 'win') {
                document.getElementById('cubeHintsTable').innerHTML = cubeTableHtml;
            }

            // Generate move hints table
            let moveTableHtml = '<table><tr><th>Ход</th><th>%</th><th>%</th><th>Эквити</th></tr>';
            if (item.action === 'win') {
                moveTableHtml += `<tr class="hint-best"><td>Победа ${item.player_name} (${item.points} очков)</td><td>-</td><td>-</td><td>-</td></tr>`;
            } else {
                const firstEq = item.hints && item.hints.length > 0 ? item.hints[0].eq : null;
                (item.hints || []).forEach((hint, index) => {
                    if (hint.probs && hint.probs.length >= 2) {
                        const prob1 = hint.probs[0] ? (hint.probs[0] * 100).toFixed(1) : '-';
                        const prob2 = hint.probs[1] ? (hint.probs[1] * 100).toFixed(1) : '-';
                        const eq = hint.eq ? hint.eq.toFixed(3) : '-';
                        const displayEq = (firstEq !== null && hint.eq !== undefined && index > 0) ? (hint.eq - firstEq).toFixed(3) : eq;
                        let move = hint.move || '-';
                        let rowClass = '';
                        if (item.gnu_move && hint.move.replace(/\*/g, '') === item.gnu_move.trim().replace(/\*/g, '')) {
                            const diff = firstEq - hint.eq; // положительная разница, насколько хуже
                            if (diff < eqThreshold) {
                                rowClass = 'hint-best';
                            } else if (index >= 1 && index <= 4) {
                                rowClass = 'hint-good';
                            } else {
                                rowClass = 'hint-poor';
                            }
                        }
                        moveTableHtml += `<tr class="${rowClass}"><td>${move}</td><td>${prob1}</td><td>${prob2}</td><td>${displayEq}</td></tr>`;
                    }
                });
            }
            moveTableHtml += '</table>';
            if (item.action === 'win') {
                document.getElementById('moveHintsTable').innerHTML = '';
                document.getElementById('cubeHintsTable').innerHTML = '';
            } else {
                document.getElementById('moveHintsTable').innerHTML = moveTableHtml;
            }
        }

        async function prevTurn() {
            if (animating) {
                skipAnimation = true;
                pendingPrevGame = true;
                setTimeout(() => {
                    if (pendingPrevGame) {
                        pendingPrevGame = false;
                        if (current > 0) {
                            current--;
                            render(current, invertColors);
                            updateButtons();
                            updateInfo();
                        }
                    }
                }, 50);
                return;
            }

            if (dataLoaded) {
                if (current > 0) {
                    let newCurrent = current - 1;
                    while (newCurrent >= 0 && !data[newCurrent].is_visible) {
                        newCurrent--;
                    }
                    if (newCurrent >= 0) {
                        render(newCurrent, invertColors);
                        updateButtons();
                        return;
                    }
                }
                // If no prev visible in current game, try prev game
                if (availableGames.length > 1) {
                    const currentIndex = availableGames.findIndex(game => game.game_number == currentGameNum);
                    if (currentIndex > 0) {
                        const prevGameNum = availableGames[currentIndex - 1].game_number;
                        await loadGame(prevGameNum);
                        current = data.length - 1;
                        while (current >= 0 && !data[current].is_visible) {
                            current--;
                        }
                        if (current >= 0) {
                            render(current, invertColors);
                            updateButtons();
                        }
                    }
                }
            }
        }

        function drawBoardForAnimation(positions) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(boardImg, 0, 0, canvas.width, canvas.height);

            updateCurrentCube(current);

            const currentPlayer = data[current].player.toLowerCase();
            drawCheckers('red', whiteImg, positions.red, currentPlayer);
            drawCheckers('black', blackImg, positions.black, currentPlayer);

            const turnData = data[current];
            if (turnData && turnData.dice && turnData.dice.length >= 2 && !['double', 'take', 'win'].includes(turnData.action)) {
                const [d1, d2] = turnData.dice;
                const diceY = 350;
                let diceX1, diceX2;
                let diceSet;
                if (invertColors) {
                    if (currentPlayer === 'red') {
                        diceX1 = 130;
                        diceX2 = 220;
                        diceSet = diceImages.white;
                    } else {
                        diceX1 = 530;
                        diceX2 = 620;
                        diceSet = diceImages.black;
                    }
                } else {
                    if (currentPlayer === 'red') {
                        diceX1 = 530;
                        diceX2 = 620;
                        diceSet = diceImages.white;
                    } else {
                        diceX1 = 130;
                        diceX2 = 220;
                        diceSet = diceImages.black;
                    }
                }
                if (diceSet[d1]) ctx.drawImage(diceSet[d1], diceX1, diceY, 60, 60);
                if (diceSet[d2]) ctx.drawImage(diceSet[d2], diceX2, diceY, 60, 60);
            }

            // Draw cube
            if (current < firstDoubleIndex) {
                ctx.drawImage(Double64, 375, 350, 50, 50);
            }

            for (let i = 0; i < doubleTurns.length; i++) {
                const doubleIndex = doubleTurns[i];
                if (current === doubleIndex) {
                    const cubeValue = data[doubleIndex].cube;
                    const doubleImages = {
                        2: Double2,
                        4: Double4,
                        8: Double8,
                        16: Double16,
                        32: Double32,
                        64: Double64
                    };
                    const img = doubleImages[cubeValue];
                    if (img) {
                        let cubeX;
                        if (invertColors) {
                            if (data[doubleIndex].player === 'Red') {
                                cubeX = 175; // куб справа для красных при инверсии
                            } else {
                                cubeX = 575; // куб слева для черных при инверсии
                            }
                        } else {
                            if (data[doubleIndex].player === 'Red') {
                                cubeX = 575; // куб слева для красных
                            } else {
                                cubeX = 175; // куб справа для черных
                            }
                        }
                        ctx.drawImage(img, cubeX, 350, 50, 50);
                    }
                    break;
                }
            }

            if (currentCube && current > firstDoubleIndex && !doubleTurns.includes(current) && turnData.action !== 'win') {
                let cubeY = 350;
                if (invertColors) {
                    if (currentCubePlayer === 'Red') {
                        cubeY = 600;
                    } else if (currentCubePlayer === 'Black') {
                        cubeY = 100;
                    }
                } else {
                    if (currentCubePlayer === 'Black') {
                        cubeY = 600;
                    } else if (currentCubePlayer === 'Red') {
                        cubeY = 100;
                    }
                }
                ctx.drawImage(currentCube, 375, cubeY, 50, 50);
            }

            if (turnData.action === 'win') {
                ctx.drawImage(Double64, 375, 350, 50, 50);
            }
        }

        function animateSingleMove(move, playerType, temp_positions, callback) {
            const img = playerType === 'red' ? whiteImg : blackImg;
            const player_pos = temp_positions[playerType];
            const opp_pos = temp_positions[playerType === 'red' ? 'black' : 'red'];
            const fromStr = move.from.toString();
            const toStr = move.to.toString()
            let fromX, fromY;
            const rawFrom = move.from;
            const fromIsBar = (rawFrom === 'bar' || rawFrom === 25 || rawFrom === '25');
            const rawTo = move.to;
            const isOff = (rawTo === 'off' || rawTo === 0 || rawTo === '0');
            const isBar = (rawTo === 'bar' || rawTo === 25 || rawTo === '25');
            if (fromIsBar) {
                fromX = 400;
                const barY = (playerType === 'black') ? 220 : 520;
                const barDy = (playerType === 'black') ? 55 : -55;
                const barCount = player_pos['bar'] || 0;
                fromY = barY + (barCount - 1) * barDy;
            } else {
                const fromPoint = parseInt(fromStr);
                fromX = getX(fromPoint);
                const fromBaseY = getBaseY(fromPoint);
                const fromDy = getDy(fromPoint);
                const fromCount = player_pos[fromStr] || 0;
                fromY = fromBaseY + (fromCount - 1) * fromDy;
            }

            if (fromIsBar) {
                player_pos['bar'] = (player_pos['bar'] || 1) - 1;
                if (player_pos['bar'] === 0) delete player_pos['bar'];
            } else {
                player_pos[fromStr] = (player_pos[fromStr] || 1) - 1;
                if (player_pos[fromStr] === 0) delete player_pos[fromStr];
            }

            let toX, toY;
            if (isOff) {
                toX = 820;
                toY = playerType === 'black'
                    ? (invertColors ? 440 : 340)
                    : (invertColors ? 340 : 440);
            } else {
                const toPoint = parseInt(toStr);
                toX = getX(toPoint);
                const toBaseY = getBaseY(toPoint);
                const toDy = getDy(toPoint);
                let toCount = player_pos[toStr] || 0;
                if (move.hit) {
                    toCount = 0; // After hit, place on empty point
                }
                toY = toBaseY + toCount * toDy;
            }

            let progress = 0;
            const duration = 200 / animationSpeed; // Duration for smooth animation
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);
                // Ease-in-out for smoother movement
                const easedProgress = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                const currentX = fromX + (toX - fromX) * easedProgress;
                const currentY = fromY + (toY - fromY) * easedProgress;

                drawBoardForAnimation(temp_positions);
                ctx.drawImage(img, currentX - 31.25, currentY - 31.25, 62.5, 62.5);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Add checker to to position
                    if (toStr === 'off') {
                        player_pos['off'] = (player_pos['off'] || 0) + 1;
                    } else {
                        player_pos[toStr] = (player_pos[toStr] || 0) + 1;
                    }
                    callback(move.hit, move, playerType, temp_positions);
                }
            };
            animate();
        }

        function animateHit(move, playerType, temp_positions, finalCallback) {
            const hitPlayerType = playerType === 'red' ? 'black' : 'red';
            const img = hitPlayerType === 'red' ? whiteImg : blackImg;
            const opp_pos = temp_positions[hitPlayerType];

            const toStr = move.to.toString();
            // Temporarily remove hit checker from to position
            opp_pos[toStr] = (opp_pos[toStr] || 1) - 1;
            if (opp_pos[toStr] === 0) delete opp_pos[toStr];

            const hitPoint = parseInt(toStr);
            const fromX = getX(hitPoint);
            const fromBaseY = getBaseY(hitPoint);
            const fromDy = getDy(hitPoint);
            const hitCount = opp_pos[toStr] || 0; // Now 0
            let fromY = fromBaseY + (hitCount - 1) * fromDy;

            const barX = 400;
            const barY = (hitPlayerType === 'black') ? 220 : 520;
            const barDy = (hitPlayerType === 'black') ? 55 : -55;
            const barCount = opp_pos['bar'] || 0;
            const toX = 820; // Fly to the right
            const toY = barY + barCount * barDy; // Position for the hit checker on bar

            let progress = 0;
            const duration = 200 / animationSpeed;
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);
                // Ease-in-out for smoother movement
                const easedProgress = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                const currentX = fromX + (barX - fromX) * easedProgress;
                const currentY = fromY + (toY - fromY) * easedProgress;

                drawBoardForAnimation(temp_positions);
                ctx.drawImage(img, currentX - 31.25, currentY - 31.25, 62.5, 62.5);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Add hit checker to bar
                    opp_pos['bar'] = (opp_pos['bar'] || 0) + 1;
                    finalCallback();
                }
            };
            animate();
        }

        function updateTempPositionsAfterMove(move, playerType, temp_positions) {
            const player_pos = temp_positions[playerType];
            const opp_pos = temp_positions[playerType === 'red' ? 'black' : 'red'];
            const fromStr = move.from.toString();
            const toStr = move.to.toString();
            const isOffMove = (move.to === 0 || move.to === '0' || move.to === 'off');
            const isBarFrom = (move.from === 25 || move.from === '25' || move.from === 'bar');
            if (move.hit) {
                opp_pos[toStr] = (opp_pos[toStr] || 1) - 1;
                if (opp_pos[toStr] === 0) delete opp_pos[toStr];
                opp_pos['bar'] = (opp_pos['bar'] || 0) + 1;
            }

            if (isBarFrom) {
                player_pos['bar'] = (player_pos['bar'] || 1) - 1;
                if (player_pos['bar'] <= 0) delete player_pos['bar'];
            } else {
                player_pos[fromStr] = (player_pos[fromStr] || 1) - 1;
                if (player_pos[fromStr] === 0) delete player_pos[fromStr];
            }
            if (isOffMove) {
                player_pos['off'] = (player_pos['off'] || 0) + 1;
            } else {
                player_pos[toStr] = (player_pos[toStr] || 0) + 1;
            }
        }

        function nextTurn() {
            if (skipAnimationEnabled) {
                if (dataLoaded) {
                    if (current < data.length - 1) {
                        let newCurrent = current + 1;
                        while (newCurrent < data.length && !data[newCurrent].is_visible) {
                            newCurrent++;
                        }
                        if (newCurrent < data.length) {
                            render(newCurrent, invertColors);
                            updateButtons();
                            return;
                        }
                    }
                    // If no next visible in current game, try next game
                    if (availableGames.length > 1) {
                        const currentIndex = availableGames.findIndex(game => game.game_number == currentGameNum);
                        if (currentIndex !== -1 && currentIndex < availableGames.length - 1) {
                            const nextGameNum = availableGames[currentIndex + 1].game_number;
                            loadGame(nextGameNum);
                        }
                    }
                }
                return;
            }

            // Если уже идет анимация - устанавливаем флаг пропуска
            if (animating) {
                skipAnimation = true;
                return;
            }

            if (dataLoaded) {
                if (current >= data.length - 1) {
                    // If no next visible in current game, try next game
                    if (availableGames.length > 1) {
                        const currentIndex = availableGames.findIndex(game => game.game_number == currentGameNum);
                        if (currentIndex !== -1 && currentIndex < availableGames.length - 1) {
                            const nextGameNum = availableGames[currentIndex + 1].game_number;
                            loadGame(nextGameNum);
                        }
                    } else {
                        return;
                    }
                } else {

                    animating = true;
                    skipAnimation = false; // Сбрасываем флаг
                    updateButtons();
                    updateInfo(); // Обновляем инфо сразу

                    const nextTurnData = data[current];
                    const playerType = nextTurnData.player.toLowerCase();

                    let prev_positions;
                    if (current === 0) {
                        // Initial positions
                        if (invertColors) {
                            prev_positions = {
                                red: { '1': 2, '12': 5, '17': 3, '19': 5, 'bar': 0, 'off': 0 },
                                black: { '6': 5, '8': 3, '13': 5, '24': 2, 'bar': 0, 'off': 0 }
                            };
                        } else {
                            prev_positions = {
                                red: { '24': 2, '6': 5, '8': 3, '13': 5, 'bar': 0, 'off': 0 },
                                black: { '1': 2, '19': 5, '17': 3, '12': 5, 'bar': 0, 'off': 0 }
                            };
                        }
                    } else {
                        prev_positions = invertColors ? data[current - 1].inverted_positions : data[current - 1].positions;
                    }

                    const temp_positions = JSON.parse(JSON.stringify(prev_positions));

                    let moves = nextTurnData.moves || [];
                    const toScreenPoint = (p) => {
                        if (p === 'off' || p === 0) return 'off';
                        if (p === 'bar' || p === 25) return 'bar';
                        const n = Number(p);
                        if (!Number.isFinite(n) || n < 1 || n > 24) return p;
                        let boardP = (playerType === 'black') ? (25 - n) : n;
                        return invertColors ? (25 - boardP) : boardP;
                    };

                    moves = moves.map(m => ({
                        ...m,
                        from: toScreenPoint(m.from),
                        to: toScreenPoint(m.to),
                    }));

                    const timeoutId = setTimeout(() => {
                        animating = false;
                        updateButtons();
                    }, 5000);

                    if (moves.length > 0) {
                        let moveIndex = 0;
                        const animateMoves = () => {
                            // Проверяем флаг пропуска
                            if (skipAnimation) {
                                // Применяем все оставшиеся ходы мгновенно
                                while (moveIndex < moves.length) {
                                    const move = moves[moveIndex];
                                    updateTempPositionsAfterMove(move, playerType, temp_positions);
                                    moveIndex++;
                                }
                                // Завершаем анимацию
                                clearTimeout(timeoutId);
                                current++;
                                render(current, invertColors);
                                updateButtons();
                                updateInfo();
                                animating = false;
                                skipAnimation = false;
                                return;
                            }

                            if (moveIndex < moves.length) {
                                const move = moves[moveIndex];
                                animateSingleMove(move, playerType, temp_positions, (hasHit, move, playerType, temp_positions) => {
                                    if (hasHit) {
                                        animateHit(move, playerType, temp_positions, () => {
                                            moveIndex++;
                                            setTimeout(animateMoves, 100 / animationSpeed);
                                        });
                                    } else {
                                        moveIndex++;
                                        setTimeout(animateMoves, 100 / animationSpeed);
                                    }
                                });
                            } else {
                                clearTimeout(timeoutId);
                                current++;
                                render(current, invertColors);
                                updateButtons();
                                updateInfo();
                                animating = false;
                            }
                        };
                        animateMoves();
                    } else {
                        clearTimeout(timeoutId);
                        current++;
                        render(current, invertColors);
                        updateButtons();
                        updateInfo();
                        animating = false;
                    }
                }
            }
        }

        function toggleInvert() {
            invertColors = !invertColors;
            render(current, invertColors);
        }

        function updateInfo() {
            if (!dataLoaded) return;

            const turnLabel = document.getElementById('turnLabel');
            turnLabel.textContent = data[current].turn || 'End';

            const moveInfo = document.getElementById('move-info');
            const item = data[current];
            let info = '';
            let prefix = (current > 0 && data[current - 1].action === 'double') ? '<strong>Take</strong>  <br>' : '';
            if (item.action === 'double') {
                info = `Double (${item.cube})`;
            } else if (item.action === 'take') {
                info = `Take`;
            } else if (item.action === 'win') {
                // Найти следующую игру для счета
                const nextGame = availableGames.find(g => g.game_number > currentGameNum);
                let finalRedScore, finalBlackScore;
                if (nextGame) {
                    // Загрузить scores из файла следующей игры
                    fetch(`/api/analysis/${gameId}?game_num=${nextGame.game_number}`)
                        .then(response => response.json())
                        .then(json => {
                            const nextScores = json.game_info.scores || {};
                            finalRedScore = nextScores.Red || 0;
                            finalBlackScore = nextScores.Black || 0;
                            const larger = Math.max(finalRedScore, finalBlackScore);
                            const smaller = Math.min(finalRedScore, finalBlackScore);
                            const winInfo = `${item.player_name} победил. Счёт ${larger} - ${smaller}`;
                            document.getElementById('move-info').innerHTML = winInfo;
                        })
                        .catch(error => {
                            console.error('Error loading next game scores:', error);
                            // Fallback to current logic
                            finalRedScore = gameRedScore;
                            finalBlackScore = gameBlackScore;
                            if (item.player_name === redPlayer) {
                                finalRedScore += item.points;
                            } else if (item.player_name === blackPlayer) {
                                finalBlackScore += item.points;
                            }
                            const larger = Math.max(finalRedScore, finalBlackScore);
                            const smaller = Math.min(finalRedScore, finalBlackScore);
                            info = `${item.player_name} победил. Счёт ${larger} - ${smaller}`;
                        });
                    return; // Exit early, info will be set asynchronously
                } else {
                    // Если следующей игры нет, используем текущую логику
                    finalRedScore = gameRedScore;
                    finalBlackScore = gameBlackScore;
                    if (item.player_name === redPlayer) {
                        finalRedScore += item.points;
                    } else if (item.player_name === blackPlayer) {
                        finalBlackScore += item.points;
                    }
                }
                const larger = Math.max(finalRedScore, finalBlackScore);
                const smaller = Math.min(finalRedScore, finalBlackScore);
                info = `${item.player_name} победил. Счёт ${larger} - ${smaller}`;
            } else if (item.moves && item.moves.length > 0) {
                info = prefix + `${item.gnu_move ? item.gnu_move.trim() : ''}`;
            } else if (item.moves && item.moves.length === 0) {
                info = prefix + `Пропуск`;
            } else {
                info = prefix + '<div class="info-text">No moves available for this turn.</div>';
                console.warn('No moves for turn:', current, item);
            }
            setTimeout(() => {
                document.getElementById('move-info').innerHTML = info;
                console.log('Info set to:', info);
                console.log('Actual move-info div content:', document.getElementById('move-info').innerHTML);
            }, 0);
        }

        function showFadingMessage(message) {
            const msgDiv = document.createElement('div');
            msgDiv.style.position = 'fixed';
            msgDiv.style.top = '50%';
            msgDiv.style.left = '50%';
            msgDiv.style.transform = 'translate(-50%, -50%)';
            msgDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            msgDiv.style.color = 'white';
            msgDiv.style.padding = '10px 20px';
            msgDiv.style.borderRadius = '5px';
            msgDiv.style.fontSize = '16px';
            msgDiv.style.zIndex = '10000';
            msgDiv.innerHTML = message;
            document.body.appendChild(msgDiv);
            setTimeout(() => {
                msgDiv.style.transition = 'opacity 1s';
                msgDiv.style.opacity = '0';
                setTimeout(() => msgDiv.remove(), 1000);
            }, 1000);
        }

        function saveScreenshot() {
            // Hide controls and game selector before taking screenshot
            const controls = document.getElementById('controls');
            const invertBtn = document.getElementById('invertBtn');
            const screenshotBtn = document.getElementById('screenshotBtn');
            const gameSelect = document.getElementById('gameSelect');
            const hintsButtons = document.querySelector('.hints-buttons');
            const hideInfoCheckbox = document.getElementById('hideInfoCheckbox');
            const playersInfo = document.getElementById('players-info');
            const screenSaveBtn = document.getElementById('screenSaveBtn');
            const screenUploadBtn = document.getElementById('screenUploadBtn');
            const animationControls = document.querySelector('.animation-controls');
            const supportContainer = document.querySelector('.support-container');
            const settingsContainer = document.querySelector('.settings-container');
            let animationControlsParent = null;
            let animationControlsNextSibling = null;
            if (animationControls) {
                animationControlsParent = animationControls.parentNode;
                animationControlsNextSibling = animationControls.nextSibling;
                animationControlsParent.removeChild(animationControls);
            }
            const originalControlsDisplay = controls ? controls.style.display : null;
            const originalInvertDisplay = invertBtn ? invertBtn.style.display : null;
            const originalScreenshotDisplay = screenshotBtn ? screenshotBtn.style.display : null;
            const originalGameSelectDisplay = gameSelect ? gameSelect.style.display : null;
            const originalHintsButtonsDisplay = hintsButtons ? hintsButtons.style.display : null;
            const originalHideInfoCheckboxDisplay = hideInfoCheckbox ? hideInfoCheckbox.style.display : null;
            const originalPlayersInfoDisplay = playersInfo ? playersInfo.style.display : null;
            const originalScreenSaveBtnDisplay = screenSaveBtn ? screenSaveBtn.style.display : null;
            const originalScreenUploadBtnDisplay = screenUploadBtn ? screenUploadBtn.style.display : null;
            const originalSupportDisplay = supportContainer ? supportContainer.style.display : null;
            const originalSettingsDisplay = settingsContainer ? settingsContainer.style.display : null;
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsSpan = settingsContainer ? settingsContainer.querySelector('span') : null;
            const originalSettingsBtnDisplay = settingsBtn ? settingsBtn.style.display : null;
            const originalSettingsSpanDisplay = settingsSpan ? settingsSpan.style.display : null;
            const originalPlayersInfoHTML = playersInfo ? playersInfo.innerHTML : '';
            const matchInfo = document.getElementById('match-info');
            const originalMatchInfoHTML = matchInfo ? matchInfo.innerHTML : '';
            const crawfordLabel = document.getElementById('crawfordLabel');
            const originalCrawfordDisplay = crawfordLabel ? crawfordLabel.style.display : 'none';
            const blackPips = document.getElementById('black-pips');
            const redPips = document.getElementById('red-pips');
            const originalBlackPipsDisplay = blackPips ? blackPips.style.display : 'none';
            const originalRedPipsDisplay = redPips ? redPips.style.display : 'none';

            function restoreControls() {
                if (controls && originalControlsDisplay !== null) controls.style.display = originalControlsDisplay;
                if (invertBtn && originalInvertDisplay !== null) invertBtn.style.display = originalInvertDisplay;
                if (screenshotBtn && originalScreenshotDisplay !== null) screenshotBtn.style.display = originalScreenshotDisplay;
                if (gameSelect && originalGameSelectDisplay !== null) gameSelect.style.display = originalGameSelectDisplay;
                if (hintsButtons && originalHintsButtonsDisplay !== null) hintsButtons.style.display = originalHintsButtonsDisplay;
                if (hideInfoCheckbox && originalHideInfoCheckboxDisplay !== null) hideInfoCheckbox.style.display = originalHideInfoCheckboxDisplay;
                if (screenSaveBtn && originalScreenSaveBtnDisplay !== null) screenSaveBtn.style.display = originalScreenSaveBtnDisplay;
                if (screenUploadBtn && originalScreenUploadBtnDisplay !== null) screenUploadBtn.style.display = originalScreenUploadBtnDisplay;
                if (supportContainer && originalSupportDisplay !== null) supportContainer.style.display = originalSupportDisplay;
                if (settingsBtn && originalSettingsBtnDisplay !== null) settingsBtn.style.display = originalSettingsBtnDisplay;
                if (settingsSpan && originalSettingsSpanDisplay !== null) settingsSpan.style.display = originalSettingsSpanDisplay;
                if (settingsContainer && originalSettingsDisplay !== null) settingsContainer.style.display = originalSettingsDisplay;
                if (settingsContainer && originalSettingsDisplay !== null) settingsContainer.style.display = originalSettingsDisplay;
                if (animationControls && animationControlsParent) {
                    if (animationControlsNextSibling) {
                        animationControlsParent.insertBefore(animationControls, animationControlsNextSibling);
                    } else {
                        animationControlsParent.appendChild(animationControls);
                    }
                }
                if (playersInfo) {
                    if (originalPlayersInfoDisplay !== null) playersInfo.style.display = originalPlayersInfoDisplay;
                    playersInfo.innerHTML = originalPlayersInfoHTML;
                }
                if (matchInfo && originalMatchInfoHTML !== null) {
                    matchInfo.innerHTML = originalMatchInfoHTML;
                }
                if (crawfordLabel && originalCrawfordDisplay !== null) crawfordLabel.style.display = originalCrawfordDisplay;
                if (blackPips && originalBlackPipsDisplay !== null) blackPips.style.display = originalBlackPipsDisplay;
                if (redPips && originalRedPipsDisplay !== null) redPips.style.display = originalRedPipsDisplay;
                if (settingsContainer && originalSettingsDisplay !== null) settingsContainer.style.display = originalSettingsDisplay;
            }

            controls.style.display = 'none';
            invertBtn.style.display = 'none';
            screenshotBtn.style.display = 'none';
            if (gameSelect) gameSelect.style.display = 'none';
            if (hintsButtons) hintsButtons.style.display = 'none';
            if (hideInfoCheckbox) hideInfoCheckbox.style.display = 'none';
            if (screenSaveBtn) screenSaveBtn.style.display = 'none';
            if (screenUploadBtn) screenUploadBtn.style.display = 'none';
            if (supportContainer) supportContainer.style.display = 'none';
            if (settingsContainer) settingsContainer.style.display = 'none';
            if (settingsBtn) settingsBtn.style.display = 'none';
            if (settingsSpan) settingsSpan.style.display = 'none';
            // Keep crawfordLabel visible for screenshots
            if (hideInfoCheckbox && hideInfoCheckbox.checked) {
                if (playersInfo) {
                    playersInfo.style.display = 'none';
                }
                if (matchInfo && matchLength > 0) {
                    matchInfo.innerHTML = `<div style="position: relative;"><span style="position: absolute; left: 0;">Матч до ${matchLength}</span><span style="position: absolute; left: 50%; transform: translateX(-50%);">Счет: ${gameRedScore} - ${gameBlackScore}</span></div>`;
                }
                if (gameSelect) gameSelect.style.display = 'none';
            }

            if (hidePipsCheckbox && hidePipsCheckbox.checked) {
                if (blackPips) blackPips.style.display = 'none';
                if (redPips) redPips.style.display = 'none';
            }

            if (hidePipsCheckbox && hidePipsCheckbox.checked) {
                if (blackPips) blackPips.style.display = 'none';
                if (redPips) redPips.style.display = 'none';
            }

            html2canvas(document.body, { useCORS: true, allowTaint: true, backgroundColor: '#1a1a1a' }).then(canvas => {
                canvas.toBlob(blob => {
                    const formData = new FormData();
                    formData.append('photo', blob);
                    fetch(`/api/save_screenshot?chat_id=${chatId}`, {
                        method: 'POST',
                        body: formData
                    }).then(response => {
                        if (response.ok) {
                            showFadingMessage('Скриншот сохранен в буфер');
                        } else {
                            showFadingMessage('Ошибка при сохранении скриншота');
                        }
                        restoreControls();
                    }).catch(error => {
                        console.error('Error saving screenshot:', error);
                        showFadingMessage('Ошибка при сохранении скриншота');
                        restoreControls();
                    });
                });
            }).catch(error => {
                console.error('Error creating screenshot:', error);
                showFadingMessage('Ошибка при создании скриншота');
                restoreControls();
            });
        }

        function uploadScreenshots() {
            fetch(`/api/upload_screenshots?chat_id=${chatId}`, { method: 'POST' }).then(response => {
                if (response.ok) {
                    showFadingMessage('Скриншоты отправлены');
                } else {
                    showFadingMessage('Ошибка при отправке скриншотов');
                }
            }).catch(error => {
                console.error('Error uploading screenshots:', error);
                showFadingMessage('Ошибка при отправке скриншотов');
            });
        }

        function updateButtons() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');

            if (dataLoaded) {
                // Найти предыдущий видимый ход
                let prevVisible = current - 1;
                while (prevVisible >= 0 && !data[prevVisible].is_visible) {
                    prevVisible--;
                }
                const hasPrev = prevVisible >= 0 || (availableGames.length > 1 && availableGames.findIndex(game => game.game_number == currentGameNum) > 0);
                prevBtn.disabled = !hasPrev;

                // Найти следующий видимый ход
                let nextVisible = current + 1;
                while (nextVisible < data.length && !data[nextVisible].is_visible) {
                    nextVisible++;
                }
                const hasNext = nextVisible < data.length || (availableGames.length > 1 && availableGames.findIndex(game => game.game_number == currentGameNum) < availableGames.length - 1);
                nextBtn.disabled = !hasNext;
            } else {
                prevBtn.disabled = true;
                nextBtn.disabled = true;
            }
        }

        function takeScreenshot() {
            // Hide controls and game selector before taking screenshot
            const controls = document.getElementById('controls');
            const invertBtn = document.getElementById('invertBtn');
            const screenshotBtn = document.getElementById('screenshotBtn');
            const gameSelect = document.getElementById('gameSelect');
            const hintsButtons = document.querySelector('.hints-buttons');
            const hideInfoCheckbox = document.getElementById('hideInfoCheckbox');
            const playersInfo = document.getElementById('players-info');
            const screenSaveBtn = document.getElementById('screenSaveBtn');
            const screenUploadBtn = document.getElementById('screenUploadBtn');
            const animationControls = document.querySelector('.animation-controls');
            const supportContainer = document.querySelector('.support-container');
            const settingsContainer = document.querySelector('.settings-container');
            let animationControlsParent = null;
            let animationControlsNextSibling = null;
            if (animationControls) {
                animationControlsParent = animationControls.parentNode;
                animationControlsNextSibling = animationControls.nextSibling;
                animationControlsParent.removeChild(animationControls);
            }
            const originalControlsDisplay = controls ? controls.style.display : null;
            const originalInvertDisplay = invertBtn ? invertBtn.style.display : null;
            const originalScreenshotDisplay = screenshotBtn ? screenshotBtn.style.display : null;
            const originalGameSelectDisplay = gameSelect ? gameSelect.style.display : null;
            const originalHintsButtonsDisplay = hintsButtons ? hintsButtons.style.display : null;
            const originalHideInfoCheckboxDisplay = hideInfoCheckbox ? hideInfoCheckbox.style.display : null;
            const originalPlayersInfoDisplay = playersInfo ? playersInfo.style.display : null;
            const originalScreenSaveBtnDisplay = screenSaveBtn ? screenSaveBtn.style.display : null;
            const originalScreenUploadBtnDisplay = screenUploadBtn ? screenUploadBtn.style.display : null;
            const originalSupportDisplay = supportContainer ? supportContainer.style.display : null;
            const originalSettingsDisplay = settingsContainer ? settingsContainer.style.display : null;
            const originalPlayersInfoHTML = playersInfo ? playersInfo.innerHTML : '';
            const matchInfo = document.getElementById('match-info');
            const originalMatchInfoHTML = matchInfo ? matchInfo.innerHTML : null;
            const crawfordLabel = document.getElementById('crawfordLabel');
            const originalCrawfordDisplay = crawfordLabel ? crawfordLabel.style.display : null;

            function restoreControls() {
                if (controls && originalControlsDisplay !== null) controls.style.display = originalControlsDisplay;
                if (invertBtn && originalInvertDisplay !== null) invertBtn.style.display = originalInvertDisplay;
                if (screenshotBtn && originalScreenshotDisplay !== null) screenshotBtn.style.display = originalScreenshotDisplay;
                if (gameSelect && originalGameSelectDisplay !== null) gameSelect.style.display = originalGameSelectDisplay;
                if (hintsButtons && originalHintsButtonsDisplay !== null) hintsButtons.style.display = originalHintsButtonsDisplay;
                if (hideInfoCheckbox && originalHideInfoCheckboxDisplay !== null) hideInfoCheckbox.style.display = originalHideInfoCheckboxDisplay;
                if (screenSaveBtn && originalScreenSaveBtnDisplay !== null) screenSaveBtn.style.display = originalScreenSaveBtnDisplay;
                if (screenUploadBtn && originalScreenUploadBtnDisplay !== null) screenUploadBtn.style.display = originalScreenUploadBtnDisplay;
                if (supportContainer && originalSupportDisplay !== null) supportContainer.style.display = originalSupportDisplay;
                if (animationControls && animationControlsParent) {
                    if (animationControlsNextSibling) {
                        animationControlsParent.insertBefore(animationControls, animationControlsNextSibling);
                    } else {
                        animationControlsParent.appendChild(animationControls);
                    }
                }
                if (playersInfo) {
                    if (originalPlayersInfoDisplay !== null) playersInfo.style.display = originalPlayersInfoDisplay;
                    playersInfo.innerHTML = originalPlayersInfoHTML;
                }
                if (matchInfo && originalMatchInfoHTML !== null) {
                    matchInfo.innerHTML = originalMatchInfoHTML;
                }
                if (crawfordLabel && originalCrawfordDisplay !== null) crawfordLabel.style.display = originalCrawfordDisplay;
                if (settingsContainer && originalSettingsDisplay !== null) settingsContainer.style.display = originalSettingsDisplay;
            }

            controls.style.display = 'none';
            invertBtn.style.display = 'none';
            screenshotBtn.style.display = 'none';
            if (gameSelect) gameSelect.style.display = 'none';
            if (hintsButtons) hintsButtons.style.display = 'none';
            if (hideInfoCheckbox) hideInfoCheckbox.style.display = 'none';
            if (screenSaveBtn) screenSaveBtn.style.display = 'none';
            if (screenUploadBtn) screenUploadBtn.style.display = 'none';
            if (supportContainer) supportContainer.style.display = 'none';
            if (settingsContainer) settingsContainer.style.display = 'none';
            // Keep crawfordLabel visible for screenshots
            if (hideInfoCheckbox && hideInfoCheckbox.checked) {
                if (playersInfo) {
                    playersInfo.style.display = 'none';
                }
                if (matchInfo && matchLength > 0) {
                    matchInfo.innerHTML = `<div style="position: relative;"><span style="position: absolute; left: 0;">Матч до ${matchLength}</span><span style="position: absolute; left: 50%; transform: translateX(-50%);">Счет: ${gameRedScore} - ${gameBlackScore}</span></div>`;
                }
                if (gameSelect) gameSelect.style.display = 'none';
            }

            // Create a canvas to capture the entire page
            html2canvas(document.body, {
                useCORS: true,
                allowTaint: true,
                backgroundColor: '#1a1a1a'
            }).then(canvas => {
                restoreControls();
                // Convert canvas to blob
                canvas.toBlob(blob => {
                    // Create a file from the blob
                    const file = new File([blob], 'screenshot.png', { type: 'image/png' });

                    // Send the file to Telegram
                    if (window.Telegram && window.Telegram.WebApp) {
                        // Use Telegram WebApp API to send the file
                        const formData = new FormData();
                        formData.append('photo', file);

                        // Use chat_id from global variable
                        const currentChatId = chatId;

                        // You might need to adjust this based on your backend API
                        fetch(`/api/send_screenshot?chat_id=${chatId}`, {
                            method: 'POST',
                            body: formData
                        }).then(response => {
                            if (response.ok) {
                            } else {
                                response.text().then(text => {
                                    console.error('Server response:', text);
                                    try {
                                        const errorData = JSON.parse(text);
                                        alert('Ошибка при отправке скриншота: ' + (errorData.detail || text));
                                    } catch (e) {
                                        alert('Ошибка при отправке скриншота: ' + text);
                                    }
                                });
                            }
                        }).catch(error => {
                            console.error('Error sending screenshot:', error);
                            alert('Ошибка при отправке скриншота: ' + error);
                        });
                    } else {
                        const link = document.createElement('a');
                        link.download = 'screenshot.png';
                        link.href = canvas.toDataURL();
                        link.click();
                    }
                });
            }).catch(error => {
                console.error('Error creating screenshot:', error);
                alert('Ошибка при создании скриншота: ' + error.message);
                restoreControls();
            });
        }

        // Функция для создания снежинок
        function createSnowflakes() {
            const snowflakesCount = 15;
            const snowflakes = ['❄', '☃', '❅', '❆'];

            for (let i = 0; i < snowflakesCount; i++) {
                const snowflake = document.createElement('div');
                snowflake.classList.add('snowflake');
                snowflake.textContent = snowflakes[Math.floor(Math.random() * snowflakes.length)];

                const randomX = Math.random() * 100; // От 0 до 100% ширины экрана
                const randomDuration = 8 + Math.random() * 8; // От 8 до 16 секунд
                const randomDelay = Math.random() * 5; // Задержка от 0 до 5 секунд
                const animationDirection = Math.random() > 0.5 ? 'snowfall' : 'snowfall-left';

                snowflake.style.left = randomX + '%';
                snowflake.style.animation = `${animationDirection} ${randomDuration}s linear ${randomDelay}s infinite`;
                snowflake.style.fontSize = (0.8 + Math.random() * 0.8) + 'em';

                document.body.appendChild(snowflake);
            }
        }

        // Запускаем снежинки при загрузке страницы
        window.addEventListener('load', createSnowflakes);
        // Если документ уже загружен
        if (document.readyState === 'complete') {
            createSnowflakes();
        }

        function openSupportModal() {
            document.getElementById('supportModal').style.display = 'block';
            document.getElementById('supportText').value = '';
        }

        function closeSupportModal() {
            document.getElementById('supportModal').style.display = 'none';
        }

        window.onclick = function (event) {
            const modal = document.getElementById('supportModal');
            if (event.target == modal) {
                closeSupportModal();
            }
        }

        function sendToSupport() {
            const text = document.getElementById('supportText').value;
            if (!text.trim()) {
                alert('Пожалуйста, введите описание проблемы');
                return;
            }

            const sendBtn = document.getElementById('sendSupportBtn');
            const originalBtnText = sendBtn.innerText;
            sendBtn.disabled = true;
            sendBtn.innerText = 'Отправка...';

            // Hide screenshot-related UI elements for capture
            const supportContainer = document.querySelector('.support-container');
            const originalSupportDisplay = supportContainer.style.display;
            supportContainer.style.display = 'none';

            // Still hide modal as requested previously
            const modal = document.getElementById('supportModal');
            const originalModalDisplay = modal.style.display;
            modal.style.display = 'none';

            html2canvas(document.body, {
                useCORS: true,
                allowTaint: true,
                backgroundColor: '#1a1a1a'
            }).then(canvas => {
                canvas.toBlob(blob => {
                    const formData = new FormData();
                    formData.append('photo', blob);
                    formData.append('text', text);
                    formData.append('chat_id', chatId);

                    // Create AbortController for timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

                    fetch('/api/send_to_support', {
                        method: 'POST',
                        body: formData,
                        signal: controller.signal
                    }).then(async response => {
                        clearTimeout(timeoutId);
                        if (response.ok) {
                            showFadingMessage('Сообщение отправлено в техподдержку');
                        } else if (response.status === 429) {
                            const data = await response.json();
                            const waitText = (data.detail && data.detail.wait_text) ? data.detail.wait_text : 'некоторое время';
                            alert(`Слишком много запросов. Пожалуйста, подождите ${waitText} перед следующей отправкой.`);
                            modal.style.display = originalModalDisplay;
                        } else {
                            alert('Ошибка при отправке сообщения');
                            modal.style.display = originalModalDisplay;
                        }
                    }).catch(error => {
                        clearTimeout(timeoutId);
                        console.error('Error sending to support:', error);
                        if (error.name === 'AbortError') {
                            alert('Плохое соединение. Таймаут 10 секунд. Попробуйте позже.');
                        } else {
                            alert('Ошибка при отправке сообщения');
                        }
                        modal.style.display = originalModalDisplay;
                    }).finally(() => {
                        sendBtn.disabled = false;
                        sendBtn.innerText = originalBtnText;
                        supportContainer.style.display = originalSupportDisplay;
                    });
                });
            }).catch(error => {
                console.error('Error creating screenshot:', error);
                alert('Ошибка при создании скриншота');
                modal.style.display = originalModalDisplay;
                sendBtn.disabled = false;
                sendBtn.innerText = originalBtnText;
                supportContainer.style.display = originalSupportDisplay;
            });
        }

        // Settings Modal Functions
        function openSettingsModal() {
            document.getElementById('settingsModal').style.display = 'block';
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function switchTab(tabName) {
            event.preventDefault();
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active class from all tab buttons
            const tabBtns = document.querySelectorAll('.tab-btn');
            tabBtns.forEach(btn => {
                btn.classList.remove('active');
            });

            // Show the selected tab content
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
            }

            // Add active class to the clicked button
            event.target.classList.add('active');
        }

        function saveSettings() {
            // Save settings to localStorage if needed
            showFadingMessage('Настройки сохранены');
            closeSettingsModal();
        }

        // Close settings modal when clicking outside of it
        window.addEventListener('click', function (event) {
            const settingsModal = document.getElementById('settingsModal');
            const supportModal = document.getElementById('supportModal');

            if (event.target === settingsModal) {
                closeSettingsModal();
            }
            if (event.target === supportModal) {
                closeSupportModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                const settingsModal = document.getElementById('settingsModal');
                const supportModal = document.getElementById('supportModal');

                if (settingsModal.style.display === 'block') {
                    closeSettingsModal();
                }
                if (supportModal.style.display === 'block') {
                    closeSupportModal();
                }
            }
        });

        function generateXGID() {
            if (!dataLoaded || !data || current === undefined) {
                console.error('Data not loaded');
                return '';
            }

            let xgid = "";
            
            // Get current positions (всегда используем обычные positions, инверсия применяется ниже)
            let redPositions, blackPositions;
            if (current === 0) {
                // Начальная позиция (всегда без инверсии)
                redPositions = { '24': 2, '6': 5, '8': 3, '13': 5, 'bar': 0, 'off': 0 };
                blackPositions = { '1': 2, '19': 5, '17': 3, '12': 5, 'bar': 0, 'off': 0 };
            } else {
                const prevTurn = current - 1;
                // Всегда берем обычные positions
                redPositions = data[prevTurn].positions['red'];
                blackPositions = data[prevTurn].positions['black'];
            }

            // Determine upper and lower positions based on invertColors
            // In XGID: upper = строчные (a-o), lower = заглавные (A-O)
            // In hint_viewer: red = white (нижний), black = black (верхний) when not inverted
            // When inverted: red = верхний, black = нижний
            const upperPositions = invertColors ? redPositions : blackPositions;
            const lowerPositions = invertColors ? blackPositions : redPositions;
            
            // Bar для верхнего игрока (первый символ в XGID)
            const upperBar = upperPositions.bar || 0;
            if (upperBar === 0) {
                xgid += "-";
            } else if (upperBar <= 15) {
                // Верхний игрок = строчные буквы (a-o)
                xgid += String.fromCharCode(96 + upperBar);
            }
            
            // Positions 1-24
            for (let point = 1; point <= 24; point++) {
                const lowerCount = lowerPositions[point.toString()] || 0;
                const upperCount = upperPositions[point.toString()] || 0;

                if (lowerCount > 0) {
                    if (lowerCount <= 15) {
                        // Нижний = заглавные (A-O)
                        xgid += String.fromCharCode(64 + lowerCount);
                    }
                } else if (upperCount > 0) {
                    if (upperCount <= 15) {
                        // Верхний = строчные (a-o)
                        xgid += String.fromCharCode(96 + upperCount);
                    }
                } else {
                    xgid += "-";
                }
            }
            
            // Bar для нижнего игрока (последний символ перед ':' в XGID)
            const lowerBar = lowerPositions.bar || 0;
            if (lowerBar === 0) {
                xgid += "-";
            } else if (lowerBar <= 15) {
                // Нижний игрок = заглавные буквы (A-O)
                xgid += String.fromCharCode(64 + lowerBar);
            }
            
            xgid += ':';
            
            // Cube exponent (part 1)
            let cubeValue = 0;
            if (currentCube) {
                // Find cube value from currentCube image
                const cubeValues = { Double2: 2, Double4: 4, Double8: 8, Double16: 16, Double32: 32, Double64: 64 };
                cubeValue = cubeValues[currentCube] || 0;
            }
            let exponent = 0;
            if (cubeValue > 0) {
                exponent = Math.log2(cubeValue);
            }
            xgid += exponent.toString();
            
            xgid += ':';
            
            // Cube position (part 2): 1 = lower, -1 = upper, 0 = no cube
            let cubePosition = 0;
            if (cubeValue !== 0 && currentCubePlayer) {
                const isLowerPlayer = invertColors ? 
                    (currentCubePlayer === 'Black') : 
                    (currentCubePlayer === 'Red');
                cubePosition = isLowerPlayer ? 1 : -1;
            }
            xgid += cubePosition.toString();
            
            xgid += ':';
            
            // Turn (part 3): 1 = lower, -1 = upper
            const currentItem = data[current];
            const currentPlayer = currentItem.player || '';
            let turnValue = 0;
            if (currentPlayer) {
                const isLowerPlayerTurn = invertColors ? 
                    (currentPlayer === 'Black') : 
                    (currentPlayer === 'Red');
                turnValue = isLowerPlayerTurn ? 1 : -1;
            }
            xgid += turnValue.toString();
            
            xgid += ':';
            
            // Cube part (part 4): dice or 'D' or '00'
            let cubePart = '00';
            if (currentItem.dice && currentItem.dice.length >= 2 && !['double', 'take', 'win'].includes(currentItem.action)) {
                const [d1, d2] = currentItem.dice;
                cubePart = d1.toString() + d2.toString();
            } else if (cubeValue > 0 && currentCubePlayer) {
                // Cube is shown
                cubePart = 'D';
            }
            xgid += cubePart;
            
            xgid += ':';
            
            // Scores (parts 5-6)
            const lowerScore = matchLength > 0 ? (invertColors ? gameBlackScore : gameRedScore) : '0';
            const upperScore = matchLength > 0 ? (invertColors ? gameRedScore : gameBlackScore) : '0';
            xgid += lowerScore.toString();
            xgid += ':';
            xgid += upperScore.toString();
            
            xgid += ':';
            
            // Convention (part 7)
            let conventionPart = '0';
            if (matchLength > 0) {
                // Match: 1 if Crawford, 0 otherwise
                const isCrawford = enable_crawford_game_number !== null && currentGameNum >= enable_crawford_game_number;
                conventionPart = isCrawford ? '1' : '0';
            } else {
                // Money game: jacobi + 2*beaver (default 0)
                conventionPart = '0';
            }
            xgid += conventionPart;
            
            xgid += ':';
            
            // Match length (part 8)
            const matchLengthPart = matchLength > 0 ? matchLength.toString() : '0';
            xgid += matchLengthPart;
            
            xgid += ':';
            
            // Max cube (part 9) - default to 3 (8) if not available
            const maxCubePart = '3'; // Default value, can be extracted from gameInfo if available
            xgid += maxCubePart;
            
            return xgid;
        }
        
        function openPokazEditor() {
            try {
                const xgidString = generateXGID();
                if (!xgidString) {
                    alert('Не удалось сгенерировать XGID строку');
                    return;
                }
                
                // Get chat_id from URL or use current
                const urlParams = new URLSearchParams(window.location.search);
                const currentChatId = urlParams.get('chat_id') || chatId || '';
                
                // Build URL with XGID and chat_id (relative URL for same app navigation)
                const pokazUrl = `/pokaz?xgid=${encodeURIComponent(xgidString)}${currentChatId ? '&chat_id=' + encodeURIComponent(currentChatId) : ''}`;
                
                // Navigate in same window/app (works in Telegram WebApp and browser)
                window.location.href = pokazUrl;
            } catch (error) {
                console.error('Error opening pokaz editor:', error);
                alert('Ошибка при открытии редактора: ' + error.message);
            }
        }
    </script>
</body>

</html>