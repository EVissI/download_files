<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backgammon Game Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            color: white;
            background-color: #1a1a1a;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        h1 {
            display: none;
        }

        canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background-color: #2a2a2a;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto 20px;
        }

        .game-info {
            background-color: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin: 20px auto;
            border: 1px solid #444;
            width: 50%;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .hints-table {
            background-color: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #444;
            overflow-x: auto;
        }

        table {
            margin: 0 auto;
            border-collapse: collapse;
            width: 100%;
            max-width: 800px;
            background-color: #333;
            border-radius: 6px;
            overflow: hidden;
        }

        th,
        td {
            border: 1px solid #555;
            padding: 20px 30px;
            text-align: left;
            color: white;
            word-spacing: 16px;
        }

        th {
            background-color: #444;
            font-weight: bold;
            text-align: center;
        }

        tr:nth-child(even) {
            background-color: #2a2a2a;
        }

        tr:hover {
            background-color: #3a3a3a;
        }

        .hint-best {
            background-color: #2e7d32 !important;
        }

        .hint-good {
            background-color: #fbc02d !important;
        }

        .hint-good td {
            color: #1a1a1a !important;
        }

        .hint-poor {
            background-color: #d32f2f !important;
        }

        #controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            width: 100%;
        }

        .turn-display {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        #turnLabel {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
            margin: 0;
            min-width: 80px;
            text-align: center;
        }

        .info-text {
            color: #ccc;
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 2rem;
            }

            .pips-above-board,
            .pips-below-board {
                font-size: 16px;
                padding: 8px 16px;
            }

            canvas {
                width: 100%;
                height: 100%;
            }

            #controls {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                justify-content: center;
                width: 100%;
            }

            #turnLabel {
                margin: 10px 0;
                font-size: 16px;
            }

            button {
                width: 60px;
                padding: 10px 20px;
            }

            table {
                font-size: 24px;
            }

            th,
            td {
                padding: 8px 12px;
                word-spacing: 12px;
            }

            .container {
                padding: 0 10px;
            }

            .hints-table {
                padding: 15px;
                margin: 15px 0;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5rem;
            }

            canvas {
                width: 100%;
                height: 100%;
            }

            button {
                width: 60px;
                padding: 8px 16px;
                font-size: 14px;
            }

            table {
                font-size: 16px;
            }

            th,
            td {
                padding: 6px 8px;
                word-spacing: 4px;
            }
        }

        .loading {
            color: #007bff;
            font-style: italic;
        }

        .error {
            color: #dc3545;
            background-color: #2d1b1b;
            border: 1px solid #dc3545;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }

        .pips-above-board {
            background-color: #000000;
            color: #ffffff;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 1px;
            text-align: right;
            display: block;
            width: fit-content;
            margin-left: auto;
        }

        .pips-below-board {
            background-color: #ffffff;
            color: #000000;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            margin-top: -20px;
            text-align: right;
            display: block;
            width: fit-content;
            margin-left: auto;
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const gameId = urlParams.get('game_id') || 'default';
    </script>
</head>

<body>
    <div class="container">
        <h1>Backgammon Game Analysis</h1>
        <div id="players-info"></div>
        <div id="black-pips" class="pips-above-board">0</div>
        <canvas id="boardCanvas" width="800" height="800"></canvas>
        <div id="red-pips" class="pips-below-board">0</div>

        <div id="controls">
            <button onclick="prevTurn()" id="prevBtn">←</button>
            <span id="turnLabel">Ход 0</span>
            <button onclick="nextTurn()" id="nextBtn">→</button>
        </div>
        <div class="game-info">
            <div id="info" class="info-text"></div>
        </div>

        <div class="hints-table">
            <div id="hints"></div>
        </div>
    </div>

    <script>
        if (window.Telegram) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
        }

        let data = [];
        let dataLoaded = false;
        let redPlayer = 'Unknown';
        let blackPlayer = 'Unknown';
        const infoDiv = document.getElementById('info');
        const playersInfoDiv = document.getElementById('players-info');
        infoDiv.innerHTML = '<div class="loading">Loading game data...</div>';

        fetch(`/api/analysis/${gameId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(json => {
                data = json.filter(item => item.turn !== undefined);
                data = data.filter(it => ((Array.isArray(it.moves)) || it.action === 'win' || it.action === 'double') && it.action !== 'take' && it.action !== 'pass');

                // Найти все индексы ходов с удвоением
                doubleTurns = data.map((item, index) => item.action === 'double' ? index : -1).filter(idx => idx !== -1);
                firstDoubleIndex = doubleTurns.length > 0 ? doubleTurns[0] : -1;

                if (data.length > 0) {
                    redPlayer = data.find(item => item.player === 'Red' || item.player === 'red')?.player_name || 'Unknown';
                    blackPlayer = data.find(item => item.player === 'Black' || item.player === 'black')?.player_name || 'Unknown';
                    playersInfoDiv.innerHTML = `Белые: ${redPlayer} – Черные: ${blackPlayer}`;
                    dataLoaded = true;
                    console.log('Data loaded:', data);
                    console.log('First turn data:', data[0]);
                    console.log('First turn moves:', data[0]?.moves);
                    if (data[0]?.action === 'skip') {
                        current = 1;
                    }
                    if (imagesLoaded === 21) {
                        render(current);
                        updateButtons();
                        infoDiv.innerHTML = '';
                    } else {
                        console.log('Waiting for images to load before rendering');
                    }
                } else {
                    infoDiv.innerHTML = '<div class="error">No game data found for this game ID.</div>';
                }
            })
            .catch(error => {
                console.error('Error loading JSON:', error);
                infoDiv.innerHTML = '<div class="error">Error loading game data. Please check the game ID and try again.</div>';
            });

        let current = 0;
        let doubleTurns = [];
        let firstDoubleIndex = -1;
        let currentCube = null;
        let currentCubePlayer = null;
        const canvas = document.getElementById('boardCanvas');
        const ctx = canvas.getContext('2d');

        const boardImg = new Image();
        boardImg.src = '/static/board.png';

        const blackImg = new Image();
        blackImg.src = '/static/black_checker.png';

        const whiteImg = new Image();
        whiteImg.src = '/static/white_checker.png';

        const Dice1w = new Image();
        Dice1w.src = '/static/1w.png';
        const Dice2w = new Image();
        Dice2w.src = '/static/2w.png';
        const Dice3w = new Image();
        Dice3w.src = '/static/3w.png';
        const Dice4w = new Image();
        Dice4w.src = '/static/4w.png';
        const Dice5w = new Image();
        Dice5w.src = '/static/5w.png';
        const Dice6w = new Image();
        Dice6w.src = '/static/6w.png';

        const Dice1b = new Image();
        Dice1b.src = '/static/1b.png';
        const Dice2b = new Image();
        Dice2b.src = '/static/2b.png';
        const Dice3b = new Image();
        Dice3b.src = '/static/3b.png';
        const Dice4b = new Image();
        Dice4b.src = '/static/4b.png';
        const Dice5b = new Image();
        Dice5b.src = '/static/5b.png';
        const Dice6b = new Image();
        Dice6b.src = '/static/6b.png';

        const Double2 = new Image();
        Double2.src = '/static/Double2.png';
        const Double4 = new Image();
        Double4.src = '/static/Double4.png';
        const Double8 = new Image();
        Double8.src = '/static/Double8.png';
        const Double16 = new Image();
        Double16.src = '/static/Double16.png';
        const Double32 = new Image();
        Double32.src = '/static/Double32.png';
        const Double64 = new Image();
        Double64.src = '/static/Double64.png';

        let imagesLoaded = 0;
        const checkImagesLoaded = () => {
            imagesLoaded++;
            console.log('Images loaded:', imagesLoaded);
            if (imagesLoaded === 21 && dataLoaded) {
                console.log('All images and data loaded, rendering turn', current);
                render(current);
                updateButtons();
                infoDiv.innerHTML = '';
            }
        };

        boardImg.onload = checkImagesLoaded;
        blackImg.onload = checkImagesLoaded;
        whiteImg.onload = checkImagesLoaded;
        Dice1w.onload = checkImagesLoaded;
        Dice2w.onload = checkImagesLoaded;
        Dice3w.onload = checkImagesLoaded;
        Dice4w.onload = checkImagesLoaded;
        Dice5w.onload = checkImagesLoaded;
        Dice6w.onload = checkImagesLoaded;
        Dice1b.onload = checkImagesLoaded;
        Dice2b.onload = checkImagesLoaded;
        Dice3b.onload = checkImagesLoaded;
        Dice4b.onload = checkImagesLoaded;
        Dice5b.onload = checkImagesLoaded;
        Dice6b.onload = checkImagesLoaded;
        Double2.onload = checkImagesLoaded;
        Double4.onload = checkImagesLoaded;
        Double8.onload = checkImagesLoaded;
        Double16.onload = checkImagesLoaded;
        Double32.onload = checkImagesLoaded;
        Double64.onload = checkImagesLoaded;

        // Обработка ошибок загрузки изображений
        [boardImg, blackImg, whiteImg, Dice1w, Dice2w, Dice3w, Dice4w, Dice5w, Dice6w, Dice1b, Dice2b, Dice3b, Dice4b, Dice5b, Dice6b, Double2, Double4, Double8, Double16, Double32, Double64].forEach(img => {
            img.onerror = () => {
                console.error(`Failed to load image: ${img.src}`);
                infoDiv.innerHTML = '<div class="error">Error loading game assets. Please try again later.</div>';
            };
        });

        const diceImages = {
            white: {
                1: Dice1w,
                2: Dice2w,
                3: Dice3w,
                4: Dice4w,
                5: Dice5w,
                6: Dice6w
            },
            black: {
                1: Dice1b,
                2: Dice2b,
                3: Dice3b,
                4: Dice4b,
                5: Dice5b,
                6: Dice6b
            }
        };

        function getX(point) {
            if (point >= 13 && point <= 18) {
                const baseX = 50 + (point - 13) * 60;
                return baseX - (point === 13 ? 8 : 0);
            } else if (point >= 19 && point <= 24) {
                return 450 + (point - 19) * 60;
            } else if (point >= 7 && point <= 12) {
                const baseX = 50 + (12 - point) * 60;
                return baseX - (point === 12 ? 4 : 0);
            } else if (point >= 1 && point <= 6) {
                return 450 + (6 - point) * 60;
            }
            return 0;
        }

        function getBaseY(point) {
            return (point > 12) ? 70 : 690;
        }

        function getDy(point) {
            return (point > 12) ? 55 : -55;
        }

        function calculatePips(positions, player) {
            let totalPips = 0;
            for (let pointStr in positions) {
                if (pointStr === 'bar') {
                    totalPips += Math.abs(positions[pointStr]) * 25;
                } else if (pointStr === 'off') {
                } else {
                    const point = parseInt(pointStr);
                    const count = positions[pointStr];
                    if (player === 'black') {
                        totalPips += count * (25 - point);
                    } else {
                        totalPips += count * point;
                    }
                }
            }
            return totalPips;
        }

        function drawCheckers(player, img, positions, currentPlayer) {
            ctx.font = 'bold 30px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (player === currentPlayer) {
                for (let point = 1; point <= 24; point++) {
                    const x = getX(point);
                    let y = getBaseY(point);
                    const dy = getDy(point);

                    let displayPoint = point;
                    if (player === 'black') {
                        displayPoint = 25 - point; // Black sees points inverted (24 at top-right, 1 at bottom-left)
                    } else if (player === 'red') {
                        displayPoint = point; // Red sees points starting from bottom-left (1 at bottom-left, 24 at top-right)
                    }
                    let numberY;
                    if (point > 12) {
                        numberY = y - 50; // Above for upper half
                    } else {
                        numberY = y + 60; // Below for lower half
                    }
                    ctx.fillText(displayPoint, x, numberY);
                }
            }

            for (let pointStr in positions) {
                if (pointStr === 'bar' || pointStr === 'off') continue;
                const point = parseInt(pointStr);
                let count = positions[pointStr];
                const x = getX(point);
                let y = getBaseY(point);
                const dy = getDy(point);

                for (let i = 0; i < Math.min(count, 6); i++) {
                    ctx.drawImage(img, x - 31.25, y + (i * dy) - 31.25, 62.5, 62.5);
                }

                if (count > 6) {
                    const lastCheckerY = y + (5 * dy);
                    ctx.fillText(`${count}`, x + 40, lastCheckerY + 5);
                }
            }

            const barX = 400;
            const barY = (player === 'black') ? 220 : 520;
            if (positions.bar && positions.bar !== 0) {
                let y = barY;
                const dy = (player === 'black') ? 55 : -55;
                for (let i = 0; i < Math.min(Math.abs(positions.bar), 6); i++) {
                    ctx.drawImage(img, barX - 31.25, y + (i * dy) - 31.25, 62.5, 62.5);
                }
                if (Math.abs(positions.bar) > 6) {
                    const lastCheckerY = y + (5 * dy);
                    ctx.fillText(`(${Math.abs(positions.bar)})`, barX + 30, lastCheckerY + 5);
                }
            }

            const offX = 783;
            const offY = (player === 'black') ? 340 : 440;
            if (positions.off && positions.off !== 0) {
                const originalFont = ctx.font;  
                ctx.font = 'bold 32px Arial';  
                ctx.fillText(`${positions.off}`, offX, offY);
                ctx.font = originalFont;  
            }
        }

        function render(turn) {
            if (!data || !data[turn]) {
                console.error('No data for turn:', turn);
                document.getElementById('info').innerHTML = '<div class="error">No data available for this turn.</div>';
                return;
            }

            current = turn;
            document.getElementById('turnLabel').innerText = `Ход ${data[turn].turn || 'End'}`;
            console.log('Rendering turn:', turn, 'Data:', data[turn]);

            ctx.clearRect(0, 0, 800, 800);
            ctx.drawImage(boardImg, 0, 0, 800, 800);

            let redPositions, blackPositions;
            if (turn === 0) {
                redPositions = { '24': 2, '6': 5, '8': 3, '13': 5, 'bar': 0, 'off': 0 };
                blackPositions = { '1': 2, '19': 5, '17': 3, '12': 5, 'bar': 0, 'off': 0 };
            } else {
                const prevTurn = turn - 1;
                redPositions = data[prevTurn].positions['red'];
                blackPositions = data[prevTurn].positions['black'];
            }
            const currentPlayer = data[turn].player.toLowerCase();
            drawCheckers('red', whiteImg, redPositions, currentPlayer);
            drawCheckers('black', blackImg, blackPositions, currentPlayer);

            // Calculate pips
            const redPips = calculatePips(redPositions, 'red');
            const blackPips = calculatePips(blackPositions, 'black');

            document.getElementById('black-pips').innerText = `${blackPips}`;
            document.getElementById('red-pips').innerText = `${redPips}`;

            ctx.fillStyle = '#000000';
            ctx.fillRect(650, -50, 150, 50);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${blackPips}`, 725, -20);

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(650, 800, 150, 50);
            ctx.fillStyle = '#000000';
            ctx.fillText(`${redPips}`, 725, 830);

            const item = data[turn];
            if (item.dice && item.dice.length >= 2 && !['double', 'take', 'win'].includes(item.action)) {
                const [d1, d2] = item.dice;
                const diceY = 350;

                let diceX1, diceX2;
                let diceSet;
                if (item.player === 'Red') {
                    diceX1 = 530; // кубики справа для красных
                    diceX2 = 620;
                    diceSet = diceImages.white;
                } else {
                    diceX1 = 130; // кубики слева для черных
                    diceX2 = 220;
                    diceSet = diceImages.black;
                }

                if (diceSet[d1]) ctx.drawImage(diceSet[d1], diceX1, diceY, 60, 60);
                if (diceSet[d2]) ctx.drawImage(diceSet[d2], diceX2, diceY, 60, 60);
                }
    

                if (turn < firstDoubleIndex) {
                    ctx.drawImage(Double64, 375, 350, 50, 50);
                }

                for (let i = 0; i < doubleTurns.length; i++) {
                    const doubleIndex = doubleTurns[i];
                    if (turn === doubleIndex) {
                        const cubeValue = data[doubleIndex].cube;
                        const doubleImages = {
                            2: Double2,
                            4: Double4,
                            8: Double8,
                            16: Double16,
                            32: Double32,
                            64: Double64
                        };
                        const img = doubleImages[cubeValue];
                        if (img) {
                            currentCube = img; // Запоминаем куб
                            currentCubePlayer = data[doubleIndex].player; // Запоминаем игрока
                            let cubeX;
                            if (data[doubleIndex].player === 'Red') {
                                cubeX = 130; // куб справа для красных
                            } else {
                                cubeX = 530; // куб слева для черных
                            }
                            ctx.drawImage(img, cubeX, 350, 50, 50);
                        }
                        break; 
                    }
                }

                if (currentCube && turn > firstDoubleIndex) {
                    let cubeY = 350;
                    if (currentCubePlayer === 'Black') {
                        cubeY = 600; 
                    } else if (currentCubePlayer === 'Red') {
                        cubeY = 100; 
                    }
                    ctx.drawImage(currentCube, 375, cubeY, 50, 50);
                }
                let info = '';
                let prefix = (turn > 0 && data[turn - 1].action === 'double') ? 'Takes ' : '';
                if (item.action === 'double') {
                    info =`<strong>Действие:</strong> Double (${item.cube})`;
                } else if (item.action === 'win') {
                    info =`<strong>Действие:</strong> Победа (${item.points} очков)`;
                } else if (item.moves && item.moves.length > 0) {
                    info = prefix + `<strong>Ход:</strong> ${item.gnu_move}`;
                } else if (item.moves && item.moves.length === 0) {
                    info = prefix + `<strong>Ход:</strong> Пропуск`;
                } else {
                    info = prefix + '<div class="info-text">No moves available for this turn.</div>';
                    console.warn('No moves for turn:', turn, item);
                }
                setTimeout(() => {
                    document.getElementById('info').innerHTML = info;
                    console.log('Info set to:', info);
                    console.log('Actual info div content:', document.getElementById('info').innerHTML);
                }, 0);

                let tableHtml = '<table><tr><th>Действие</th><th>Эквити</th></tr>';
                if (item.hints && item.hints.length > 0 && item.hints[0].type === 'cube') {
                    const bestAction = item.hints[0].cubeful_equities.find(eq => eq.idx === 1);
                    const bestAction1 = bestAction.action_1;
                    const bestAction2 = bestAction.action_2;
                    (item.hints[0].cubeful_equities || []).slice(0, 3).forEach((hint, index) => {
                        const eq = hint.eq ? hint.eq.toFixed(3) : '-';
                        let displayAction = hint.action_1;
                        if (hint.action_2) {
                            displayAction += `, ${hint.action_2}`;
                        }
                        let rowClass = '';
                        if (item.gnu_move === 'Double') {
                            if (index === 0) {
                                rowClass = 'hint-best';
                            } else if (index === 1) {
                                rowClass = 'hint-good';
                            } else {
                                rowClass = 'hint-poor';
                            }
                        } else if (item.gnu_move !== 'Double') {
                            if (hint.action_2 === bestAction2) {
                                if (index === 0) {
                                    rowClass = 'hint-best';
                                } else if (index === 1) {
                                    rowClass = 'hint-good';
                                } else {
                                    rowClass = 'hint-poor';
                                }
                            }
                        }
                        tableHtml += `<tr class="${rowClass}"><td>${displayAction}</td><td>${eq}</td></tr>`;
                    });
                } else {
                    tableHtml = '<table><tr><th>Ход</th><th>Вероятности, %</th><th>Эквити</th></tr>';
                    (item.hints || []).slice(0, 3).forEach((hint, index) => {
                        if (hint.probs && hint.probs.length >= 2) {
                            const prob1 = hint.probs[0] ? (hint.probs[0] * 100).toFixed(1) : '-';
                            const prob2 = hint.probs[1] ? (hint.probs[1] * 100).toFixed(1) : '-';
                            const eq = hint.eq ? hint.eq.toFixed(3) : '-';
                            let move = hint.move || '-';
                            let rowClass = '';
                            if (item.gnu_move && hint.move === item.gnu_move) {
                                if (index === 0) {
                                    rowClass = 'hint-best';
                                } else if (index >= 1 && index <= 4) {
                                    rowClass = 'hint-good';
                                } else {
                                    rowClass = 'hint-poor';
                                }
                            }
                            tableHtml += `<tr class="${rowClass}"><td>${move}</td><td>${prob1} ${prob2}</td><td>${eq}</td></tr>`;
                        }
                    });
                }
                tableHtml += '</table>';
                document.getElementById('hints').innerHTML = tableHtml;
        }

        function prevTurn() {
            if (current > 0) {
                render(current - 1);
                updateButtons();
            }
        }

        function nextTurn() {
            if (current < data.length - 1) {
                render(current + 1);
                updateButtons();
            }
        }

        function updateButtons() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');

            prevBtn.disabled = current <= 0;
            nextBtn.disabled = current >= data.length - 1;
        }
    </script>
</body>

</html>