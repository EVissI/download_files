<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backgammon Board Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            color: white;
            background-color: #1a1a1a;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        h1 {
            display: none;
        }

        canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background-color: #2a2a2a;
            max-width: 100%;
            height: 100%;
            display: block;
            margin: 0 auto 20px;
        }

        .game-info {
            background-color: #2d2d2d;
            border-radius: 8px;
            padding: 10px;
            margin: 0;
            border: 1px solid #444;
            width: 30%;
            display: block;
        }

        .hints-table {
            border-radius: 8px;
            border: 1px solid #444;
            overflow-x: auto;
        }

        .hints-buttons {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .hint-toggle-btn {
            width: 49%;
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .hint-toggle-btn:hover {
            background-color: #0056b3;
        }

        .hint-toggle-btn.active {
            background-color: #0056b3;
        }

        .hints-buttons button:hover {
            background-color: #0056b3;
        }

        .hints-buttons button.active {
            background-color: #0056b3;
        }

        .hints-content {
            display: none;
            position: relative;
        }

        .hints-content.active {
            display: block;
        }

        table {
            margin: 0 auto;
            border-collapse: collapse;
            width: 100%;
            max-width: 800px;
            border-radius: 6px;
            overflow: hidden;
        }

        th,
        td {
            border: 1px solid #555;
            padding: 20px 30px;
            text-align: left;
            color: white;
            word-spacing: 16px;
        }

        td:nth-child(2),
        td:nth-child(3),
        td:nth-child(4) {
            text-align: center;
        }

        th {
            font-weight: bold;
            text-align: center;
        }

        .hint-best {
            background-color: #2e7d32 !important;
        }

        .hint-good {
            background-color: #fbc02d !important;
        }

        .hint-good td {
            color: #1a1a1a !important;
        }

        .hint-poor {
            background-color: #d32f2f !important;
        }

        #top-row {
            margin: 0px 0;
            display: flex;
            margin-top: 10px;
            align-items: center;
            width: 100%;
            justify-content: flex-start;
        }

        .pips-container {
            margin-left: auto;
        }

        #controls {
            position: relative;
            display: flex;
            align-items: center;
            width: 100%;
            flex-wrap: wrap;
        }

        .center-controls {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .turn-display {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        select {
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: white;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 5px;
        }

        #prevBtn,
        #nextBtn,
        #invertBtn,
        #screenshotBtn,
        #screenSaveBtn,
        #screenUploadBtn {
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: 40px;
            height: 40px;
            padding: 0;
            color: transparent;
            background-color: transparent;
            border: none;
        }


        #prevBtn:hover,
        #nextBtn:hover,
        #invertBtn:hover,
        #screenshotBtn:hover,
        #screenSaveBtn:hover,
        #screenUploadBtn:hover {
            background-color: transparent;
        }

        #prevBtn:disabled,
        #nextBtn:disabled,
        #invertBtn:disabled,
        #screenshotBtn:disabled,
        #screenSaveBtn:disabled,
        #screenUploadBtn:disabled {
            opacity: 0.5;
            background-color: transparent;
        }

        #turnLabel {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
            margin: 0;
            min-width: 40px;
            text-align: center;
        }

        .info-text {
            color: #ccc;
            margin: 5px 0;
        }


        .board-footer {
            position: relative;
            margin-top: -20px;
        }

        .move-info {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
            text-align: center;
        }

        .pips-below-board {
            position: absolute;
            right: 0;
            top: 0;
            margin: 0;
        }


        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 2rem;
            }

            .pips-above-board,
            .pips-below-board {
                font-size: 16px;
                padding: 8px 16px;
            }

            canvas {
                width: 100%;
                height: 100%;
            }

            #top-row {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                justify-content: flex-start;
                width: 100%;
            }

            #controls {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                width: 100%;
            }

            #turnLabel {
                margin: 5px 0;
                font-size: 16px;
            }

            #top-row {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                justify-content: flex-start;
                width: 100%;
            }

            button {
                width: 60px;
                padding: 10px 20px;
            }

            table {
                font-size: 24px;
            }

            th,
            td {
                padding: 8px 12px;
                word-spacing: 12px;
            }

            .container {
                padding: 0 10px;
            }

            .hints-table {
                padding: 15px;
            }

            #prevBtn,
            #nextBtn,
            #invertBtn,
            #screenshotBtn,
            #screenSaveBtn,
            #screenUploadBtn {
                width: 50px;
                height: 50px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5rem;
            }

            canvas {
                width: 100%;
                height: 100%;
            }

            button {
                width: 60px;
                padding: 8px 16px;
                font-size: 14px;
            }

            table {
                font-size: 16px;
            }

            th,
            td {
                padding: 6px 8px;
                word-spacing: 4px;
            }

            #prevBtn,
            #nextBtn,
            #invertBtn,
            #screenshotBtn,
            #screenSaveBtn,
            #screenUploadBtn {
                width: 35px;
                height: 35px;
            }
        }

        @media (min-width: 1200px) {

            #prevBtn,
            #nextBtn,
            #invertBtn,
            #screenshotBtn,
            #screenSaveBtn,
            #screenUploadBtn {
                width: 100px;
                height: 100px;
            }
        }

        .loading {
            color: #007bff;
            font-style: italic;
        }

        .error {
            color: #dc3545;
            background-color: #2d1b1b;
            border: 1px solid #dc3545;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }

        .header {
            display: flex;
            flex-direction: column;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }



        #players-info {
            max-width: 800px;
            margin: 0 auto;
        }

        .pips-above-board {
            background-color: #000000;
            color: #ffffff;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            text-align: right;
            display: block;
            width: fit-content;
        }

        .pips-above-board-inverted {
            background-color: #ffffff;
            color: #000000;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            text-align: right;
            display: block;
            width: fit-content;
        }

        .pips-below-board-inverted {
            background-color: #000000;
            color: #ffffff;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            text-align: right;
            display: block;
            width: fit-content;
            position: absolute;
            right: 0;
            top: 0;
            margin: 0;
        }

        .pips-below-board {
            background-color: #ffffff;
            color: #000000;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            text-align: right;
            display: block;
            width: fit-content;
        }
    </style>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const invertBtn = document.getElementById('invertBtn');
            const screenshotBtn = document.getElementById('screenshotBtn');
            const screenSaveBtn = document.getElementById('screenSaveBtn');
            const screenUploadBtn = document.getElementById('screenUploadBtn');
            if (prevBtn) {
                prevBtn.style.backgroundImage = "url('/static/left.png?t=" + Date.now() + "')";
            }
            if (nextBtn) {
                nextBtn.style.backgroundImage = "url('/static/right.png?t=" + Date.now() + "')";
            }
            if (invertBtn) {
                invertBtn.style.backgroundImage = "url('/static/change_color.png?t=" + Date.now() + "')";
            }
            if (screenshotBtn) {
                screenshotBtn.style.backgroundImage = "url('/static/Screen.png?t=" + Date.now() + "')";
            }
            if (screenSaveBtn) {
                screenSaveBtn.style.backgroundImage = "url('/static/ScreenSave.png?t=" + Date.now() + "')";
            }
            if (screenUploadBtn) {
                screenUploadBtn.style.backgroundImage = "url('/static/ScreenUpload.png?t=" + Date.now() + "')";
            }
        });
    </script>
</head>

<body>
    <div class="container">
        <div class="header">
            <div id="match-info"></div>
            <div id="players-info"></div>
            <div id="top-row">
                <select id="gameSelect">
                    <option value="0">Game 1</option>
                </select>
                <div class="pips-container">
                    <div id="black-pips" class="pips-above-board">0</div>
                </div>
            </div>
        </div>
        <canvas id="boardCanvas" width="800" height="800"></canvas>

        <div class="board-footer">
            <div class="move-info" id="moveInfo">Initial Position</div>
            <div id="red-pips" class="pips-below-board">0</div>
            <div id="controls">
                <button onclick="toggleInvert()" id="invertBtn" title="Invert Board"></button>
                <div class="center-controls">
                    <button onclick="prevTurn()" id="prevBtn" title="Previous Move"></button>
                    <div class="turn-display">
                        <span id="turnLabel">1</span>
                    </div>
                    <button onclick="nextTurn()" id="nextBtn" title="Next Move"></button>
                </div>
            </div>
            <div id="checkboxes">
                <table style="border: none; border-collapse: collapse; width: 100%;">
                    <tr>
                        <td style="text-align: left; border: none;">Выслать скриншот экрана</td>
                        <td style="text-align: right; border: none;"><button onclick="takeScreenshot()"
                                id="screenshotBtn" title="Take Screenshot"></button></td>
                    </tr>
                    <tr>
                        <td style="text-align: left; border: none;">Добавить скриншот в буфер обмена</td>
                        <td style="text-align: right; border: none;"><button onclick="saveScreenshot()"
                                id="screenSaveBtn" title="Save Screenshot"></button></td>
                    </tr>
                    <tr>
                        <td style="text-align: left; border: none;">Выслать архив со скриншотами</td>
                        <td style="text-align: right; border: none;"><button onclick="uploadScreenshots()"
                                id="screenUploadBtn" title="Upload Screenshots"></button></td>
                    </tr>
                    <tr>
                        <td style="text-align: left; border: none;">Убрать данные матча на скриншоте</td>
                        <td style="text-align: center; border: none;"><input type="checkbox" id="hideInfoCheckbox"></td>
                    </tr>
                    <tr>
                        <td style="text-align: left; border: none;">Убрать анимацию шашек</td>
                        <td style="text-align: center; border: none;"><input type="checkbox" id="skipAnimationCheckbox">
                        </td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

    <script>
        let data = [];
        let availableGames = [];
        let current = 0;
        let currentGameNum = 1;
        let matchLength = 0;
        let gameRedScore = 0;
        let gameBlackScore = 0;
        let redPlayer = 'Unknown';
        let blackPlayer = 'Unknown';
        let inverted = false;
        let invertColors = false;
        let dataLoaded = false;
        let animating = false;
        let skipAnimation = false;
        let animationSpeed = 0.5;
        let skipAnimationEnabled = false;

        const canvas = document.getElementById('boardCanvas');
        const ctx = canvas.getContext('2d');
        const matchInfoDiv = document.getElementById('match-info');
        const playersInfoDiv = document.getElementById('players-info');

        // Load images
        const boardImg = new Image();
        boardImg.src = '/static/board.png';
        const whiteChecker = new Image();
        whiteChecker.src = '/static/white_checker.png';
        const blackChecker = new Image();
        blackChecker.src = '/static/black_checker.png';

        const Dice1w = new Image();
        Dice1w.src = '/static/1w.png?t=' + Date.now();
        const Dice2w = new Image();
        Dice2w.src = '/static/2w.png?t=' + Date.now();
        const Dice3w = new Image();
        Dice3w.src = '/static/3w.png?t=' + Date.now();
        const Dice4w = new Image();
        Dice4w.src = '/static/4w.png?t=' + Date.now();
        const Dice5w = new Image();
        Dice5w.src = '/static/5w.png?t=' + Date.now();
        const Dice6w = new Image();
        Dice6w.src = '/static/6w.png?t=' + Date.now();

        const Dice1b = new Image();
        Dice1b.src = '/static/1b.png?t=' + Date.now();
        const Dice2b = new Image();
        Dice2b.src = '/static/2b.png?t=' + Date.now();
        const Dice3b = new Image();
        Dice3b.src = '/static/3b.png?t=' + Date.now();
        const Dice4b = new Image();
        Dice4b.src = '/static/4b.png?t=' + Date.now();
        const Dice5b = new Image();
        Dice5b.src = '/static/5b.png?t=' + Date.now();
        const Dice6b = new Image();
        Dice6b.src = '/static/6b.png?t=' + Date.now();

        const diceImages = {
            white: {
                1: Dice1w,
                2: Dice2w,
                3: Dice3w,
                4: Dice4w,
                5: Dice5w,
                6: Dice6w
            },
            black: {
                1: Dice1b,
                2: Dice2b,
                3: Dice3b,
                4: Dice4b,
                5: Dice5b,
                6: Dice6b
            }
        };

        const Double2 = new Image();
        Double2.src = '/static/Double2.png?t=' + Date.now();
        const Double4 = new Image();
        Double4.src = '/static/Double4.png?t=' + Date.now();
        const Double8 = new Image();
        Double8.src = '/static/Double8.png?t=' + Date.now();
        const Double16 = new Image();
        Double16.src = '/static/Double16.png?t=' + Date.now();
        const Double32 = new Image();
        Double32.src = '/static/Double32.png?t=' + Date.now();
        const Double64 = new Image();
        Double64.src = '/static/Double64.png?t=' + Date.now();

        const cubeImages = {
            2: Double2,
            4: Double4,
            8: Double8,
            16: Double16,
            32: Double32,
            64: Double64
        };

        // Get game_id from URL
        const urlParams = new URLSearchParams(window.location.search);
        const game_id = urlParams.get('game_id');
        const chat_id = urlParams.get('chat_id')

        if (!game_id) {
            console.error('No game_id provided in URL');
            alert('No game_id provided in URL');
        }

        // Load data
        fetch(`/api/games/${game_id}`)
            .then(response => response.json())
            .then(jsonData => {
                let gamesArray;
                if (Array.isArray(jsonData)) {
                    gamesArray = jsonData;
                } else if (jsonData.games && Array.isArray(jsonData.games)) {
                    gamesArray = jsonData.games;
                } else if (jsonData.detail) {
                    alert('Error: ' + jsonData.detail);
                    return;
                } else {
                    console.error('Unexpected data format:', jsonData);
                    return;
                }
                data = gamesArray[0].turns; // Default to first game
                availableGames = gamesArray.map((game, index) => ({
                    game_number: index + 1,
                    turns: game.turns,
                    first_player: game.first.name,
                    second_player: game.second.name,
                    first_score: game.first.score,
                    second_score: game.second.score,
                    point_match: game.point_match,
                    is_long_game: game.is_long_game
                }));
                const gameInfo = gamesArray[0]
                redPlayer = gameInfo.first ? gameInfo.first.name : 'Unknown';
                blackPlayer = gameInfo.second ? gameInfo.second.name : 'Unknown';
                gameRedScore = gameInfo.first ? gameInfo.first.score : 0;
                gameBlackScore = gameInfo.second ? gameInfo.second.score : 0;
                matchPoint = gameInfo.point_match ? gameInfo.point_match : 0
                dataLoaded = true;
                const matchInfoDiv = document.getElementById('match-info');
                const matchText = matchPoint === 0 ? 'Манигейм' : `Матч до ${matchPoint}`;
                matchInfoDiv.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center;"><span>${matchText}</span><span>Игра ${currentGameNum}</span><span>Счет: ${gameRedScore} - ${gameBlackScore}</span></div>`;
                const playersInfoDiv = document.getElementById('players-info');
                playersInfoDiv.innerHTML = `Белые: ${redPlayer} – Черные: ${blackPlayer}<br>`;
                updateGameSelect();
                updateButtons();
                drawBoard();
                updateInfo();
            })
            .catch(error => {
                console.error('Error loading games data:', error);
                alert('Error loading games data: ' + error.message);
            });

        function updateGameSelect() {
            const gameSelect = document.getElementById('gameSelect');
            gameSelect.innerHTML = '';
            availableGames.forEach(game => {
                const option = document.createElement('option');
                option.value = game.game_number - 1;
                option.textContent = `Game ${game.game_number}`;
                gameSelect.appendChild(option);
            });
        }

        function drawCheckers(player, img, positions, currentPlayer) {
            ctx.font = 'bold 30px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (player === currentPlayer) {
                for (let point = 1; point <= 24; point++) {
                    const x = getX(point);
                    let y = getBaseY(point);
                    const dy = getDy(point);

                    let displayPoint = point;
                    if (invertColors) {
                        if (player === 'second') {
                            displayPoint = point;
                        } else if (player === 'first') {
                            displayPoint = 25 - point;
                        }
                    } else {
                        if (player === 'first') {
                            displayPoint = point;
                        } else if (player === 'second') {
                            displayPoint = 25 - point;
                        }
                    }
                    let numberY;
                    if (point > 12) {
                        numberY = y - 50;
                    } else {
                        numberY = y + 60;
                    }
                    ctx.fillText(displayPoint, x, numberY);
                }
            }

            for (let pointStr in positions) {
                if (pointStr === 'bar' || pointStr === 'off') continue;
                const point = parseInt(pointStr);
                let count = positions[pointStr];
                const x = getX(point);
                let y = getBaseY(point);
                const dy = getDy(point);

                for (let i = 0; i < Math.min(count, 6); i++) {
                    ctx.drawImage(img, x - 31.25, y + (i * dy) - 31.25, 62.5, 62.5);
                }

                if (count > 6) {
                    const lastCheckerY = y + (5 * dy);
                    ctx.fillText(`${count}`, x + 40, lastCheckerY + 5);
                }
            }

            const barX = 400;
            const barY = (player === 'second') ? 220 : 520;
            const barDy = (player === 'second') ? 55 : -55;
            if (positions.bar && positions.bar !== 0) {
                let y = barY;
                for (let i = 0; i < Math.min(Math.abs(positions.bar), 6); i++) {
                    ctx.drawImage(img, barX - 31.25, y + (i * barDy) - 31.25, 62.5, 62.5);
                }
                if (Math.abs(positions.bar) > 6) {
                    const lastCheckerY = y + (5 * barDy);
                    ctx.fillText(`(${Math.abs(positions.bar)})`, barX + 30, lastCheckerY + 5);
                }
            }

            let offX = 783;
            let offY = (player === 'second')
                ? (invertColors ? 440 : 340)
                : (invertColors ? 340 : 440);
            if (positions.off && positions.off !== 0) {
                const originalFont = ctx.font;
                ctx.font = 'bold 32px Arial';
                ctx.fillText(`${positions.off}`, offX, offY);
                ctx.font = originalFont;
            }
        }

        function getX(point, playerType = null) {

            let actualPoint = point;

            if (actualPoint >= 13 && actualPoint <= 18) {
                const baseX = 50 + (actualPoint - 13) * 60;
                return baseX - (actualPoint === 13 ? 8 : 0);
            } else if (actualPoint >= 19 && actualPoint <= 24) {
                return 450 + (actualPoint - 19) * 60;
            } else if (actualPoint >= 7 && actualPoint <= 12) {
                const baseX = 50 + (12 - actualPoint) * 60;
                return baseX - (actualPoint === 12 ? 4 : 0);
            } else if (actualPoint >= 1 && actualPoint <= 6) {
                return 450 + (6 - actualPoint) * 60;
            }
            return 0;
        }

        function getBaseY(point) {
            return (point > 12) ? 70 : 690;
        }

        function getDy(point) {
            return (point > 12) ? 55 : -55;
        }

        function calculatePips(positions, player, invertColors = false) {
            let totalPips = 0;
            for (let pointStr in positions) {
                if (pointStr === 'bar') {
                    totalPips += Math.abs(positions[pointStr]) * 25;
                } else if (pointStr === 'off') {
                } else {
                    const point = parseInt(pointStr);
                    const count = positions[pointStr];
                    let effectivePoint = point;
                    if (invertColors) {
                        if (player === 'red') {
                            effectivePoint = 25 - point;
                        } else if (player === 'black') {
                            effectivePoint = point;
                        }
                    } else {
                        if (player === 'black') {
                            effectivePoint = 25 - point;
                        } else if (player === 'red') {
                            effectivePoint = point;
                        }
                    }
                    totalPips += count * effectivePoint;
                }
            }
            return totalPips;
        }

        function getInitialPositions(inverted, is_long_game) {
            if (is_long_game) {
                if (inverted) {
                    return {
                        first: { '1': 1, '2': 2, '12': 5, '17': 3, '19': 5, 'bar': 0, 'off': 0 },
                        second: { '6': 5, '8': 3, '13': 5, '23': 2, '24': 1, 'bar': 0, 'off': 0 }
                    };
                } else {
                    return {
                        first: { '6': 5, '8': 3, '13': 5, '23': 2, '24': 1, 'bar': 0, 'off': 0 },
                        second: { '1': 1, '2': 2, '12': 5, '17': 3, '19': 5, 'bar': 0, 'off': 0 },
                    };
                }
            } else {
                if (inverted) {
                    return {
                        first: { '1': 2, '12': 5, '17': 3, '19': 5, 'bar': 0, 'off': 0 },
                        second: { '6': 5, '8': 3, '13': 5, '24': 2, 'bar': 0, 'off': 0 }
                    };
                } else {
                    return {
                        first: { '24': 2, '6': 5, '8': 3, '13': 5, 'bar': 0, 'off': 0 },
                        second: { '1': 2, '12': 5, '17': 3, '19': 5, 'bar': 0, 'off': 0 },
                    };
                }
            }
        }

        function drawBoard() {
            if (!dataLoaded) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw board
            ctx.drawImage(boardImg, 0, 0, canvas.width, canvas.height);

            let positions;
            if (current === 0) {
                const game = availableGames.find(g => g.game_number === currentGameNum);
                positions = getInitialPositions(inverted, game.is_long_game);
            } else {
                const prevTurn = current - 1;
                positions = inverted ? data[prevTurn].inverted_positions : data[prevTurn].positions;
            }

            invertColors = inverted;
            const game = availableGames.find(g => g.game_number === currentGameNum);
            const currentPlayerType = data[current] ? data[current].turn : null;
            const currentPlayerName = currentPlayerType ? (currentPlayerType === 'first' ? game.first_player : game.second_player) : null;
            drawCheckers('first', whiteChecker, positions.first, currentPlayerType);
            drawCheckers('second', blackChecker, positions.second, currentPlayerType);

            const redPips = calculatePips(positions.first, 'red', invertColors);
            const blackPips = calculatePips(positions.second, 'black', invertColors);

            if (invertColors) {
                document.getElementById('black-pips').innerText = `${redPips}`;
                document.getElementById('red-pips').innerText = `${blackPips}`;
                document.getElementById('black-pips').className = 'pips-above-board-inverted';
                document.getElementById('red-pips').className = 'pips-below-board-inverted';
                ctx.fillStyle = '#000000';
                ctx.fillRect(650, 800, 150, 50);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${redPips}`, 725, -20);

                ctx.fillStyle = '#ffffff';
                ctx.fillRect(650, -50, 150, 50);
                ctx.fillStyle = '#000000';
                ctx.fillText(`${blackPips}`, 725, 830);
            } else {
                document.getElementById('black-pips').innerText = `${blackPips}`;
                document.getElementById('red-pips').innerText = `${redPips}`;
                document.getElementById('black-pips').className = 'pips-above-board';
                document.getElementById('red-pips').className = 'pips-below-board';
                ctx.fillStyle = '#000000';
                ctx.fillRect(650, -50, 150, 50);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${blackPips}`, 725, -20);

                ctx.fillStyle = '#ffffff';
                ctx.fillRect(650, 800, 150, 50);
                ctx.fillStyle = '#000000';
                ctx.fillText(`${redPips}`, 725, 830);
            }

            const item = data[current];
            if (item && item.dice && item.dice.length >= 2 && !['double', 'take', 'win'].includes(item.action)) {
                const [d1, d2] = item.dice;
                const diceY = 350;
                let diceX1, diceX2;
                let diceSet;
                if (invertColors) {
                    if (currentPlayerType === 'first') {
                        diceX1 = 130;
                        diceX2 = 220;
                        diceSet = diceImages.white;
                    } else {
                        diceX1 = 530;
                        diceX2 = 620;
                        diceSet = diceImages.black;
                    }
                } else {
                    if (currentPlayerType === 'first') {
                        diceX1 = 530;
                        diceX2 = 620;
                        diceSet = diceImages.white;
                    } else {
                        diceX1 = 130;
                        diceX2 = 220;
                        diceSet = diceImages.black;
                    }
                }
                if (diceSet[d1]) ctx.drawImage(diceSet[d1], diceX1, diceY, 60, 60);
                if (diceSet[d2]) ctx.drawImage(diceSet[d2], diceX2, diceY, 60, 60);
            }

            // Draw cube
            if (item && item.cube_owner === null) {
                // Default position: cube 64 in center
                ctx.drawImage(cubeImages[64], 400 - 25, 400 - 25, 50, 50);
            } else if (item && item.cube_value && item.cube_value > 1) {
                const cubeImg = cubeImages[item.cube_value];
                if (cubeImg) {
                    let cubeX, cubeY;
                    if (item.cube_location === 'center' && item.action != 'drop') {
                        if (item.cube_owner === 'first') {
                            cubeX = 200 - 25;
                            cubeY = 400 - 25;
                        } else {
                            cubeX = 600 - 25;
                            cubeY = 400 - 25;
                        }
                    } else {
                        if (item.cube_owner === 'first') {
                            cubeX = 400 - 25;
                            cubeY = 625 - 25;
                        } else {
                            cubeX = 400 - 25;
                            cubeY = 150 - 25;
                        }
                    }
                    ctx.drawImage(cubeImg, cubeX, cubeY, 50, 50);
                }
            }
        }

        function drawBoardForAnimation(positions, currentPlayerType) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(boardImg, 0, 0, canvas.width, canvas.height);

            invertColors = inverted;
            drawCheckers('first', whiteChecker, positions.first, currentPlayerType);
            drawCheckers('second', blackChecker, positions.second, currentPlayerType);

            // Draw cube
            const turnItem = data[current];
            if (turnItem && turnItem.cube_owner === null) {
                // Default position: cube 64 in center
                ctx.drawImage(cubeImages[64], 400 - 25, 400 - 25, 50, 50);
            } else if (turnItem && turnItem.cube_value && turnItem.cube_value > 1) {
                const cubeImg = cubeImages[turnItem.cube_value];
                if (cubeImg) {
                    let cubeX, cubeY;
                    if (turnItem.cube_location === 'center') {
                        if (turnItem.cube_owner === 'first') {
                            cubeX = 100 - 25;
                            cubeY = 400 - 25;
                        } else {
                            cubeX = 700 - 25;
                            cubeY = 400 - 25;
                        }
                    } else {
                        if (item.cube_owner === 'first') {
                            cubeX = 400 - 25;
                            cubeY = 625 - 25;
                        } else {
                            cubeX = 400 - 25;
                            cubeY = 150 - 25;
                        }
                    }
                    ctx.drawImage(cubeImg, cubeX, cubeY, 50, 50);
                }
            }


            const item = data[current + 1];


            const turnData = data[current];
            if (turnData && turnData.dice && turnData.dice.length === 2 &&
                !['double', 'take', 'win'].includes(turnData.action)) {

                const [d1, d2] = turnData.dice;
                const diceY = 350;
                let diceX1, diceX2;
                let diceSet;

                if (invertColors) {
                    if (currentPlayerType === 'first') {
                        diceX1 = 130; diceX2 = 220; diceSet = diceImages.white;
                    } else {
                        diceX1 = 530; diceX2 = 620; diceSet = diceImages.black;
                    }
                } else {
                    if (currentPlayerType === 'first') {
                        diceX1 = 530; diceX2 = 620; diceSet = diceImages.white;
                    } else {
                        diceX1 = 130; diceX2 = 220; diceSet = diceImages.black;
                    }
                }

                if (diceSet[d1]) ctx.drawImage(diceSet[d1], diceX1, diceY, 60, 60);
                if (diceSet[d2]) ctx.drawImage(diceSet[d2], diceX2, diceY, 60, 60);
            }
        }
        function animateSingleMove(move, playerType, temp_positions, callback) {
            const img = playerType === 'first' ? whiteChecker : blackChecker;
            const player_pos = temp_positions[playerType];
            const opp_pos = temp_positions[playerType === 'first' ? 'second' : 'first'];
            const fromStr = move.from.toString();
            const toStr = move.to.toString()
            let fromX, fromY;
            const rawFrom = move.from;
            const fromIsBar = (rawFrom === 'bar' || rawFrom === 25 || rawFrom === '25');
            const rawTo = move.to;
            const isOff = (rawTo === 'off' || rawTo === 0 || rawTo === '0');
            const isBar = (rawTo === 'bar' || rawTo === 25 || rawTo === '25');
            if (fromIsBar) {
                fromX = 400;
                const barY = (playerType === 'second') ? 220 : 520;
                const barDy = (playerType === 'second') ? 55 : -55;
                const barCount = player_pos['bar'] || 0;
                fromY = barY + (barCount - 1) * barDy;
            } else {
                const fromPoint = parseInt(fromStr);
                fromX = getX(fromPoint, playerType);
                const fromBaseY = getBaseY(fromPoint);
                const fromDy = getDy(fromPoint);
                const fromCount = player_pos[fromStr] || 0;
                fromY = fromBaseY + (fromCount - 1) * fromDy;
            }

            if (fromIsBar) {
                player_pos['bar'] = (player_pos['bar'] || 1) - 1;
                if (player_pos['bar'] === 0) delete player_pos['bar'];
            } else {
                player_pos[fromStr] = (player_pos[fromStr] || 1) - 1;
                if (player_pos[fromStr] === 0) delete player_pos[fromStr];
            }

            let toX, toY;
            if (isOff) {
                toX = 820;
                toY = playerType === 'second'
                    ? (invertColors ? 440 : 340)
                    : (invertColors ? 340 : 440);
            } else {
                const toPoint = parseInt(toStr);
                toX = getX(toPoint, playerType);
                const toBaseY = getBaseY(toPoint);
                const toDy = getDy(toPoint);
                let toCount = player_pos[toStr] || 0;
                if (move.hit) {
                    toCount = 0; // After hit, place on empty point
                }
                toY = toBaseY + toCount * toDy;
            }

            let progress = 0;
            const duration = 200 / animationSpeed; // Duration for smooth animation
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);
                // Ease-in-out for smoother movement
                const easedProgress = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                const currentX = fromX + (toX - fromX) * easedProgress;
                const currentY = fromY + (toY - fromY) * easedProgress;

                drawBoardForAnimation(temp_positions, playerType);
                ctx.drawImage(img, currentX - 31.25, currentY - 31.25, 62.5, 62.5);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Add checker to to position
                    if (toStr === 'off') {
                        player_pos['off'] = (player_pos['off'] || 0) + 1;
                    } else {
                        player_pos[toStr] = (player_pos[toStr] || 0) + 1;
                    }
                    callback(move.hit, move, playerType, temp_positions);
                }
            };
            animate();
        }

        function animateHit(move, playerType, temp_positions, finalCallback) {
            const hitPlayerType = playerType === 'first' ? 'second' : 'first';
            const img = hitPlayerType === 'first' ? whiteChecker : blackChecker;
            const opp_pos = temp_positions[hitPlayerType];

            const toStr = move.to.toString();
            // Temporarily remove hit checker from to position
            opp_pos[toStr] = (opp_pos[toStr] || 1) - 1;
            if (opp_pos[toStr] === 0) delete opp_pos[toStr];

            const hitPoint = parseInt(toStr);
            const fromX = getX(hitPoint, hitPlayerType);
            const fromBaseY = getBaseY(hitPoint);
            const fromDy = getDy(hitPoint);
            const hitCount = opp_pos[toStr] || 0; // Now 0
            let fromY = fromBaseY + (hitCount - 1) * fromDy;

            const barX = 400;
            const barY = (hitPlayerType === 'second') ? 220 : 520;
            const barDy = (hitPlayerType === 'second') ? 55 : -55;
            const barCount = opp_pos['bar'] || 0;
            const toX = 820; // Fly to the right
            const toY = barY + barCount * barDy; // Position for the hit checker on bar

            let progress = 0;
            const duration = 200 / animationSpeed;
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);
                // Ease-in-out for smoother movement
                const easedProgress = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                const currentX = fromX + (barX - fromX) * easedProgress;
                const currentY = fromY + (toY - fromY) * easedProgress;

                drawBoardForAnimation(temp_positions, playerType);
                ctx.drawImage(img, currentX - 31.25, currentY - 31.25, 62.5, 62.5);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Add hit checker to bar
                    opp_pos['bar'] = (opp_pos['bar'] || 0) + 1;
                    finalCallback();
                }
            };
            animate();
        }

        function updateTempPositionsAfterMove(move, playerType, temp_positions) {
            const player_pos = temp_positions[playerType];
            const opp_pos = temp_positions[playerType === 'first' ? 'second' : 'first'];
            const fromStr = move.from.toString();
            const toStr = move.to.toString();
            const isOffMove = (move.to === 0 || move.to === '0' || move.to === 'off');
            const isBarFrom = (move.from === 25 || move.from === '25' || move.from === 'bar');
            if (move.hit) {
                opp_pos[toStr] = (opp_pos[toStr] || 1) - 1;
                if (opp_pos[toStr] === 0) delete opp_pos[toStr];
                opp_pos['bar'] = (opp_pos['bar'] || 0) + 1;
            }

            if (isBarFrom) {
                player_pos['bar'] = (player_pos['bar'] || 1) - 1;
                if (player_pos['bar'] <= 0) delete player_pos['bar'];
            } else {
                player_pos[fromStr] = (player_pos[fromStr] || 1) - 1;
                if (player_pos[fromStr] === 0) delete player_pos[fromStr];
            }
            if (isOffMove) {
                player_pos['off'] = (player_pos['off'] || 0) + 1;
            } else {
                player_pos[toStr] = (player_pos[toStr] || 0) + 1;
            }
        }

        function nextTurn() {
            if (skipAnimationEnabled) {
                if (current >= data.length - 1) {
                    if (currentGameNum < availableGames.length) {
                        currentGameNum++;
                        data = availableGames[currentGameNum - 1].turns;
                        current = 0;
                        updateGameSelect();
                        updateButtons();
                        drawBoard();
                        updateInfo();
                        const game = availableGames[currentGameNum - 1];
                        matchInfoDiv.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center;"><span>${game.point_match === 0 ? 'Манигейм' : `Матч до ${game.point_match}`}</span><span>Игра ${currentGameNum}</span><span>Счет: ${game.first_score} - ${game.second_score}</span></div>`;
                        redPlayer = game.first_player;
                        blackPlayer = game.second_player;
                        gameRedScore = game.first_score;
                        gameBlackScore = game.second_score;
                        playersInfoDiv.innerHTML = `Белые: ${redPlayer} – Черные: ${blackPlayer}<br>`;
                    } else {
                        return;
                    }
                } else {
                    current++;
                    drawBoard();
                    updateButtons();
                    updateInfo();
                }
                return;
            }

            // Если уже идет анимация - устанавливаем флаг пропуска
            if (animating) {
                skipAnimation = true;
                return;
            }

            if (current >= data.length - 1) {
                if (currentGameNum < availableGames.length) {
                    currentGameNum++;
                    data = availableGames[currentGameNum - 1].turns;
                    current = 0;
                    updateGameSelect();
                    updateButtons();
                    drawBoard();
                    updateInfo();
                    const game = availableGames[currentGameNum - 1];
                    matchInfoDiv.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center;"><span>${game.point_match === 0 ? 'Манигейм' : `Матч до ${game.point_match}`}</span><span>Игра ${currentGameNum}</span><span>Счет: ${game.first_score} - ${game.second_score}</span></div>`;
                    redPlayer = game.first_player;
                    blackPlayer = game.second_player;
                    gameRedScore = game.first_score;
                    gameBlackScore = game.second_score;
                    playersInfoDiv.innerHTML = `Белые: ${redPlayer} – Черные: ${blackPlayer}<br>`;
                } else {
                    return;
                }
            } else {

                animating = true;
                skipAnimation = false; // Сбрасываем флаг
                updateButtons();
                updateInfo(); // Обновляем инфо сразу

                const nextTurnData = data[current];
                const playerType = nextTurnData.turn === 'first' ? 'first' : 'second';

                let prev_positions;
                if (current === 0) {
                    const game = availableGames.find(g => g.game_number === currentGameNum);
                    prev_positions = getInitialPositions(inverted, game.is_long_game);
                } else {
                    prev_positions = inverted ? data[current - 1].inverted_positions : data[current - 1].positions;
                }

                const temp_positions = JSON.parse(JSON.stringify(prev_positions));

                let moves = nextTurnData.moves || [];
                const toScreenPoint = (p) => {
                    if (p === 'off' || p === 0) return 'off';
                    if (p === 'bar' || p === 25) return 'bar';
                    const n = Number(p);
                    if (!Number.isFinite(n) || n < 1 || n > 24) return p;
                    let boardP = (playerType === 'second') ? (25 - n) : n;
                    return inverted ? (25 - boardP) : boardP;
                };

                moves = moves.map(m => ({
                    ...m,
                    from: toScreenPoint(m.from),
                    to: toScreenPoint(m.to),
                }));

                const timeoutId = setTimeout(() => {
                    animating = false;
                    updateButtons();
                }, 5000);

                if (moves.length > 0) {
                    let moveIndex = 0;
                    const animateMoves = () => {
                        // Проверяем флаг пропуска
                        if (skipAnimation) {
                            // Применяем все оставшиеся ходы мгновенно
                            while (moveIndex < moves.length) {
                                const move = moves[moveIndex];
                                updateTempPositionsAfterMove(move, playerType, temp_positions);
                                moveIndex++;
                            }
                            // Завершаем анимацию
                            clearTimeout(timeoutId);
                            current++;
                            drawBoard();
                            updateButtons();
                            updateInfo();
                            animating = false;
                            skipAnimation = false;
                            return;
                        }

                        if (moveIndex < moves.length) {
                            const move = moves[moveIndex];
                            animateSingleMove(move, playerType, temp_positions, (hasHit, move, playerType, temp_positions) => {
                                if (hasHit) {
                                    animateHit(move, playerType, temp_positions, () => {
                                        moveIndex++;
                                        setTimeout(animateMoves, 100 / animationSpeed);
                                    });
                                } else {
                                    moveIndex++;
                                    setTimeout(animateMoves, 100 / animationSpeed);
                                }
                            });
                        } else {
                            clearTimeout(timeoutId);
                            current++;
                            drawBoard();
                            updateButtons();
                            updateInfo();
                            animating = false;
                        }
                    };
                    animateMoves();
                } else {
                    clearTimeout(timeoutId);
                    current++;
                    drawBoard();
                    updateButtons();
                    updateInfo();
                    animating = false;
                }
            }
        }

        function prevTurn() {
            if (animating) {
                skipAnimation = true;
                setTimeout(() => {
                    if (current > 0) {
                        current--;
                        drawBoard();
                        updateButtons();
                        updateInfo();
                    } else if (currentGameNum > 1) {
                        currentGameNum--;
                        data = availableGames[currentGameNum - 1].turns;
                        current = data.length - 1;
                        updateGameSelect();
                        drawBoard();
                        updateButtons();
                        updateInfo();
                        const game = availableGames[currentGameNum - 1];
                        matchInfoDiv.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center;"><span>${game.point_match === 0 ? 'Манигейм' : `Матч до ${game.point_match}`}</span><span>Игра ${currentGameNum}</span><span>Счет: ${game.first_score} - ${game.second_score}</span></div>`;
                        redPlayer = game.first_player;
                        blackPlayer = game.second_player;
                        gameRedScore = game.first_score;
                        gameBlackScore = game.second_score;
                        playersInfoDiv.innerHTML = `Белые: ${redPlayer} – Черные: ${blackPlayer}<br>`;
                    }
                }, 50);
                return;
            }

            if (current === 0) {
                if (currentGameNum > 1) {
                    currentGameNum--;
                    data = availableGames[currentGameNum - 1].turns;
                    current = data.length - 1;
                    updateGameSelect();
                    drawBoard();
                    updateButtons();
                    updateInfo();
                    const game = availableGames[currentGameNum - 1];
                    matchInfoDiv.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center;"><span>${game.point_match === 0 ? 'Манигейм' : `Матч до ${game.point_match}`}</span><span>Игра ${currentGameNum}</span><span>Счет: ${game.first_score} - ${game.second_score}</span></div>`;
                    redPlayer = game.first_player;
                    blackPlayer = game.second_player;
                    gameRedScore = game.first_score;
                    gameBlackScore = game.second_score;
                    playersInfoDiv.innerHTML = `Белые: ${redPlayer} – Черные: ${blackPlayer}<br>`;
                }
                return;
            }

            current--;
            drawBoard();
            updateButtons();
            updateInfo();
        }

        function toggleInvert() {
            inverted = !inverted;
            drawBoard();
        }

        function updateButtons() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');

            if (dataLoaded) {
                prevBtn.disabled = current === 0 && currentGameNum === 1;
                nextBtn.disabled = current === data.length - 1 && currentGameNum >= availableGames.length;
            } else {
                prevBtn.disabled = true;
                nextBtn.disabled = true;
            }
        }

        function updateInfo() {
            if (!dataLoaded) return;

            const turnLabel = document.getElementById('turnLabel');
            turnLabel.textContent = current + 1;

            const moveInfo = document.getElementById('moveInfo');
            const turn = data[current];
            const game = availableGames.find(g => g.game_number === currentGameNum);
            if (turn && turn.moves && turn.moves.length > 0) {
                const movesStr = turn.moves.map(m => `${m.from}/${m.to}${m.hit ? '*' : ''}`).join(' ');
                moveInfo.textContent = movesStr;
            } else if (turn && turn.action) {
                moveInfo.textContent = turn.action;
            } else {
                moveInfo.textContent = 'Initial Position';
            }
        }

        // Screenshot logic from hint_viewer
        function showFadingMessage(message) {
            const msgDiv = document.createElement('div');
            msgDiv.style.position = 'fixed';
            msgDiv.style.top = '50%';
            msgDiv.style.left = '50%';
            msgDiv.style.transform = 'translate(-50%, -50%)';
            msgDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            msgDiv.style.color = 'white';
            msgDiv.style.padding = '10px 20px';
            msgDiv.style.borderRadius = '5px';
            msgDiv.style.fontSize = '16px';
            msgDiv.style.zIndex = '10000';
            msgDiv.innerHTML = message;
            document.body.appendChild(msgDiv);
            setTimeout(() => {
                msgDiv.style.transition = 'opacity 1s';
                msgDiv.style.opacity = '0';
                setTimeout(() => msgDiv.remove(), 1000);
            }, 1000);
        }

        function saveScreenshot() {
            // Hide controls and game selector before taking screenshot
            const controls = document.getElementById('controls');
            const gameSelect = document.getElementById('gameSelect');
            const screenSaveBtn = document.getElementById('screenSaveBtn');
            const screenUploadBtn = document.getElementById('screenUploadBtn');
            const screenshotBtn = document.getElementById('screenshotBtn');
            const invertBtn = document.getElementById('invertBtn');
            const checkboxes = document.getElementById('checkboxes');
            const originalControlsDisplay = controls.style.display;
            const originalGameSelectDisplay = gameSelect ? gameSelect.style.display : 'none';
            const originalScreenSaveBtnDisplay = screenSaveBtn ? screenSaveBtn.style.display : 'none';
            const originalScreenUploadBtnDisplay = screenUploadBtn ? screenUploadBtn.style.display : 'none';
            const originalScreenshotDisplay = screenshotBtn ? screenshotBtn.style.display : 'none';
            const originalInvertDisplay = invertBtn ? invertBtn.style.display : 'none';
            const originalCheckboxesDisplay = checkboxes ? checkboxes.style.display : 'none';
            const originalPlayersInfoDisplay = playersInfoDiv ? playersInfoDiv.style.display : 'none';
            const originalPlayersInfoHTML = playersInfoDiv ? playersInfoDiv.innerHTML : '';
            const originalMatchInfoHTML = matchInfoDiv ? matchInfoDiv.innerHTML : '';

            controls.style.display = 'none';
            if (gameSelect) gameSelect.style.display = 'none';
            if (screenSaveBtn) screenSaveBtn.style.display = 'none';
            if (screenUploadBtn) screenUploadBtn.style.display = 'none';
            if (screenshotBtn) screenshotBtn.style.display = 'none';
            if (invertBtn) invertBtn.style.display = 'none';
            if (checkboxes) checkboxes.style.display = 'none';
            // Keep crawfordLabel visible for screenshots
            if (hideInfoCheckbox && hideInfoCheckbox.checked) {
                if (playersInfoDiv) {
                    playersInfoDiv.style.display = 'none';
                }
                if (matchInfoDiv) {
                    if (matchPoint > 0) {
                        matchInfoDiv.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center;"><span>Матч до ${matchPoint}</span><span>Счет: ${gameRedScore} - ${gameBlackScore}</span></div>`;
                    } else {
                        matchInfoDiv.innerHTML = 'Манигейм';
                    }
                }
                if (gameSelect) gameSelect.style.display = 'none';
            }

            html2canvas(document.body, { useCORS: true, allowTaint: true, backgroundColor: '#1a1a1a' }).then(canvas => {
                // Restore after screenshot
                controls.style.display = originalControlsDisplay;
                if (gameSelect) gameSelect.style.display = originalGameSelectDisplay;
                if (screenSaveBtn) screenSaveBtn.style.display = originalScreenSaveBtnDisplay;
                if (screenUploadBtn) screenUploadBtn.style.display = originalScreenUploadBtnDisplay;
                if (screenshotBtn) screenshotBtn.style.display = originalScreenshotDisplay;
                if (invertBtn) invertBtn.style.display = originalInvertDisplay;
                if (checkboxes) checkboxes.style.display = originalCheckboxesDisplay;
                if (playersInfoDiv) {
                    playersInfoDiv.style.display = originalPlayersInfoDisplay;
                    playersInfoDiv.innerHTML = originalPlayersInfoHTML;
                }
                if (matchInfoDiv) {
                    matchInfoDiv.innerHTML = originalMatchInfoHTML;
                }

                canvas.toBlob(blob => {
                    const formData = new FormData();
                    formData.append('photo', blob);
                    fetch(`/api/save_screenshot?chat_id=${chat_id}`, {
                        method: 'POST',
                        body: formData
                    }).then(response => {
                        if (response.ok) {
                            showFadingMessage('Скриншот сохранен в буфер');
                        } else {
                            showFadingMessage('Ошибка при сохранении скриншота');
                        }
                    }).catch(error => {
                        console.error('Error saving screenshot:', error);
                        showFadingMessage('Ошибка при сохранении скриншота');
                    });
                });
            }).catch(error => {
                console.error('Error creating screenshot:', error);
                controls.style.display = originalControlsDisplay;
                if (gameSelect) gameSelect.style.display = originalGameSelectDisplay;
                if (screenSaveBtn) screenSaveBtn.style.display = originalScreenSaveBtnDisplay;
                if (screenUploadBtn) screenUploadBtn.style.display = originalScreenUploadBtnDisplay;
                if (screenshotBtn) screenshotBtn.style.display = originalScreenshotDisplay;
                if (invertBtn) invertBtn.style.display = originalInvertDisplay;
                if (checkboxes) checkboxes.style.display = originalCheckboxesDisplay;
                if (playersInfoDiv) {
                    playersInfoDiv.style.display = originalPlayersInfoDisplay;
                    playersInfoDiv.innerHTML = originalPlayersInfoHTML;
                }
                if (matchInfoDiv) {
                    matchInfoDiv.innerHTML = originalMatchInfoHTML;
                }
                showFadingMessage('Ошибка при создания скриншота');
            });
        }

        function uploadScreenshots() {
            fetch(`/api/upload_screenshots?chat_id=${chat_id}`, { method: 'POST' }).then(response => {
                if (response.ok) {
                    showFadingMessage('Скриншоты отправлены');
                } else {
                    showFadingMessage('Ошибка при отправке скриншотов');
                }
            }).catch(error => {
                console.error('Error uploading screenshots:', error);
                showFadingMessage('Ошибка при отправке скриншотов');
            });
        }

        function takeScreenshot() {
            // Hide controls and game selector before taking screenshot
            const controls = document.getElementById('controls');
            const gameSelect = document.getElementById('gameSelect');
            const screenSaveBtn = document.getElementById('screenSaveBtn');
            const screenUploadBtn = document.getElementById('screenUploadBtn');
            const screenshotBtn = document.getElementById('screenshotBtn');
            const invertBtn = document.getElementById('invertBtn');
            const checkboxes = document.getElementById('checkboxes');
            const originalControlsDisplay = controls.style.display;
            const originalGameSelectDisplay = gameSelect ? gameSelect.style.display : 'none';
            const originalScreenSaveBtnDisplay = screenSaveBtn ? screenSaveBtn.style.display : 'none';
            const originalScreenUploadBtnDisplay = screenUploadBtn ? screenUploadBtn.style.display : 'none';
            const originalScreenshotDisplay = screenshotBtn ? screenshotBtn.style.display : 'none';
            const originalInvertDisplay = invertBtn ? invertBtn.style.display : 'none';
            const originalCheckboxesDisplay = checkboxes ? checkboxes.style.display : 'none';
            const originalPlayersInfoDisplay = playersInfoDiv ? playersInfoDiv.style.display : 'none';
            const originalPlayersInfoHTML = playersInfoDiv ? playersInfoDiv.innerHTML : '';
            const originalMatchInfoHTML = matchInfoDiv ? matchInfoDiv.innerHTML : '';

            controls.style.display = 'none';
            if (gameSelect) gameSelect.style.display = 'none';
            if (screenSaveBtn) screenSaveBtn.style.display = 'none';
            if (screenUploadBtn) screenUploadBtn.style.display = 'none';
            if (screenshotBtn) screenshotBtn.style.display = 'none';
            if (invertBtn) invertBtn.style.display = 'none';
            if (checkboxes) checkboxes.style.display = 'none';
            // Keep crawfordLabel visible for screenshots
            if (hideInfoCheckbox && hideInfoCheckbox.checked) {
                if (playersInfoDiv) {
                    playersInfoDiv.style.display = 'none';
                }
                if (matchInfoDiv) {
                    if (matchPoint > 0) {
                        matchInfoDiv.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center;"><span>Матч до ${matchPoint}</span><span>Счет: ${gameRedScore} - ${gameBlackScore}</span></div>`;
                    } else {
                        matchInfoDiv.innerHTML = 'Манигейм';
                    }
                }
                if (gameSelect) gameSelect.style.display = 'none';
            }

            html2canvas(document.body, {
                useCORS: true,
                allowTaint: true,
                backgroundColor: '#1a1a1a'
            }).then(canvas => {
                // Restore after screenshot
                controls.style.display = originalControlsDisplay;
                if (gameSelect) gameSelect.style.display = originalGameSelectDisplay;
                if (screenSaveBtn) screenSaveBtn.style.display = originalScreenSaveBtnDisplay;
                if (screenUploadBtn) screenUploadBtn.style.display = originalScreenUploadBtnDisplay;
                if (screenshotBtn) screenshotBtn.style.display = originalScreenshotDisplay;
                if (invertBtn) invertBtn.style.display = originalInvertDisplay;
                if (checkboxes) checkboxes.style.display = originalCheckboxesDisplay;
                if (playersInfoDiv) {
                    playersInfoDiv.style.display = originalPlayersInfoDisplay;
                    playersInfoDiv.innerHTML = originalPlayersInfoHTML;
                }
                if (matchInfoDiv) {
                    matchInfoDiv.innerHTML = originalMatchInfoHTML;
                }

                canvas.toBlob(blob => {
                    const file = new File([blob], 'screenshot.png', { type: 'image/png' });
                    const formData = new FormData();
                    formData.append('photo', file);
                    fetch(`/api/send_screenshot?chat_id=${chat_id}`, {
                        method: 'POST',
                        body: formData
                    }).then(response => {
                        if (response.ok) {
                            showFadingMessage('Скриншот отправлен');
                        } else {
                            showFadingMessage('Ошибка при отправке скриншота');
                        }
                    }).catch(error => {
                        console.error('Error sending screenshot:', error);
                        showFadingMessage('Ошибка при отправке скриншота');
                    });
                });
            }).catch(error => {
                console.error('Error creating screenshot:', error);
                controls.style.display = originalControlsDisplay;
                if (gameSelect) gameSelect.style.display = originalGameSelectDisplay;
                if (screenSaveBtn) screenSaveBtn.style.display = originalScreenSaveBtnDisplay;
                if (screenUploadBtn) screenUploadBtn.style.display = originalScreenUploadBtnDisplay;
                if (screenshotBtn) screenshotBtn.style.display = originalScreenshotDisplay;
                if (invertBtn) invertBtn.style.display = originalInvertDisplay;
                if (checkboxes) checkboxes.style.display = originalCheckboxesDisplay;
                if (playersInfoDiv) {
                    playersInfoDiv.style.display = originalPlayersInfoDisplay;
                    playersInfoDiv.innerHTML = originalPlayersInfoHTML;
                }
                if (matchInfoDiv) {
                    matchInfoDiv.innerHTML = originalMatchInfoHTML;
                }
                showFadingMessage('Ошибка при создании скриншота');
            });
        }

        // Event listeners
        document.getElementById('gameSelect').addEventListener('change', (e) => {
            const gameIndex = parseInt(e.target.value);
            currentGameNum = gameIndex + 1;
            data = availableGames[gameIndex].turns;
            gameRedScore = availableGames[gameIndex].first_score;
            gameBlackScore = availableGames[gameIndex].second_score;
            current = 0;
            inverted = false;
            const matchInfoDiv = document.getElementById('match-info');
            const matchText = availableGames[gameIndex].point_match === 0 ? 'Манигейм' : `Матч до ${availableGames[gameIndex].point_match}`;
            matchInfoDiv.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center;"><span>${matchText}</span><span>Игра ${currentGameNum}</span><span>Счет: ${gameRedScore} - ${gameBlackScore}</span></div>`;
            drawBoard();
            updateButtons();
            updateInfo();
        });

        const hideInfoCheckbox = document.getElementById('hideInfoCheckbox');
        if (hideInfoCheckbox) {
            const savedState = localStorage.getItem('hideInfoCheckbox');
            if (savedState === 'true') {
                hideInfoCheckbox.checked = true;
            }
            hideInfoCheckbox.addEventListener('change', () => {
                localStorage.setItem('hideInfoCheckbox', hideInfoCheckbox.checked);
            });
        }

        document.getElementById('skipAnimationCheckbox').addEventListener('change', (e) => {
            skipAnimationEnabled = e.target.checked;
        });

        // Draw board when images are loaded
        let imagesLoaded = 0;
        const totalImages = 21;

        function imageLoaded() {
            imagesLoaded++;
            if (imagesLoaded === totalImages && dataLoaded) {
                drawBoard();
            }
        }

        boardImg.onload = imageLoaded;
        whiteChecker.onload = imageLoaded;
        blackChecker.onload = imageLoaded;
        Dice1w.onload = imageLoaded;
        Dice2w.onload = imageLoaded;
        Dice3w.onload = imageLoaded;
        Dice4w.onload = imageLoaded;
        Dice5w.onload = imageLoaded;
        Dice6w.onload = imageLoaded;
        Dice1b.onload = imageLoaded;
        Dice2b.onload = imageLoaded;
        Dice3b.onload = imageLoaded;
        Dice4b.onload = imageLoaded;
        Dice5b.onload = imageLoaded;
        Dice6b.onload = imageLoaded;
        Double2.onload = imageLoaded;
        Double4.onload = imageLoaded;
        Double8.onload = imageLoaded;
        Double16.onload = imageLoaded;
        Double32.onload = imageLoaded;
        Double64.onload = imageLoaded;

    </script>
</body>

</html>