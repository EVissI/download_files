<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backgammon Board Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            color: white;
            background-color: #1a1a1a;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        h1 {
            display: none;
        }

        canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background-color: #2a2a2a;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto 20px;
        }


        #top-row {
            margin: 0px 0;
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            align-items: center;
            width: 100%;
        }

        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            width: 100%;
            flex-wrap: wrap;
        }

        .turn-display {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        select {
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: white;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 5px;
        }

        #prevBtn,
        #nextBtn,
        #invertBtn {
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: 40px;
            height: 40px;
            padding: 0;
            color: transparent;
            background-color: transparent;
            border: none;
        }

        #prevBtn:hover,
        #nextBtn:hover,
        #invertBtn:hover {
            background-color: transparent;
        }

        #prevBtn:disabled,
        #nextBtn:disabled,
        #invertBtn:disabled {
            opacity: 0.5;
            background-color: transparent;
        }

        #turnLabel {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
            margin: 0;
            min-width: 40px;
            text-align: center;
        }

        .info-text {
            color: #ccc;
            margin: 5px 0;
        }

        .board-footer {
            position: relative;
            margin-top: -20px;
        }

        .move-info {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
            text-align: center;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 2rem;
            }

            canvas {
                width: 100%;
                height: 100%;
            }

            #top-row {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                justify-content: space-between;
                width: 100%;
            }

            #controls {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                justify-content: center;
                width: 100%;
            }

            #turnLabel {
                margin: 5px 0;
                font-size: 16px;
            }

            #top-row {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                justify-content: space-between;
                width: 100%;
            }

            button {
                width: 60px;
                padding: 10px 20px;
            }

            .container {
                padding: 0 10px;
            }
        }
    </style>
</head>

<body>
    <div class="container">

        <div id="top-row">
            <select id="gameSelect">
                <option value="0">Game 1</option>
            </select>
        </div>

        <canvas id="boardCanvas" width="800" height="800"></canvas>

        <div class="board-footer">
            <div class="move-info" id="moveInfo">Initial Position</div>
            <div id="controls">
                <button id="prevBtn" title="Previous Move">
                    <img src="/static/left.png" alt="Previous" style="width: 100%; height: 100%;">
                </button>
                <div class="turn-display">
                    <span id="turnLabel">1</span>
                </div>
                <button id="nextBtn" title="Next Move">
                    <img src="/static/right.png" alt="Next" style="width: 100%; height: 100%;">
                </button>
                <button id="invertBtn" title="Invert Board">
                    <img src="/static/change_color.png" alt="Invert" style="width: 100%; height: 100%;">
                </button>
            </div>
        </div>
    </div>

    <script>
        let data = [];
        let availableGames = [];
        let current = 0;
        let currentGameNum = 1;
        let inverted = false;
        let invertColors = false;
        let dataLoaded = false;
        let animating = false;

        const canvas = document.getElementById('boardCanvas');
        const ctx = canvas.getContext('2d');

        // Load images (без изменений)
        const boardImg = new Image();
        boardImg.src = '/static/board.png';
        const whiteChecker = new Image();
        whiteChecker.src = '/static/white_checker.png';
        const blackChecker = new Image();
        blackChecker.src = '/static/black_checker.png';

        const Dice1w = new Image(); Dice1w.src = '/static/1w.png?t=' + Date.now();
        const Dice2w = new Image(); Dice2w.src = '/static/2w.png?t=' + Date.now();
        const Dice3w = new Image(); Dice3w.src = '/static/3w.png?t=' + Date.now();
        const Dice4w = new Image(); Dice4w.src = '/static/4w.png?t=' + Date.now();
        const Dice5w = new Image(); Dice5w.src = '/static/5w.png?t=' + Date.now();
        const Dice6w = new Image(); Dice6w.src = '/static/6w.png?t=' + Date.now();

        const Dice1b = new Image(); Dice1b.src = '/static/1b.png?t=' + Date.now();
        const Dice2b = new Image(); Dice2b.src = '/static/2b.png?t=' + Date.now();
        const Dice3b = new Image(); Dice3b.src = '/static/3b.png?t=' + Date.now();
        const Dice4b = new Image(); Dice4b.src = '/static/4b.png?t=' + Date.now();
        const Dice5b = new Image(); Dice5b.src = '/static/5b.png?t=' + Date.now();
        const Dice6b = new Image(); Dice6b.src = '/static/6b.png?t=' + Date.now();

        const diceImages = { white: {1: Dice1w,2: Dice2w,3: Dice3w,4: Dice4w,5: Dice5w,6: Dice6w},
                            black: {1: Dice1b,2: Dice2b,3: Dice3b,4: Dice4b,5: Dice5b,6: Dice6b} };

        // ... (fetch и загрузка данных без изменений)

        function getInitialPositions(inverted) {
            if (inverted) {
                return {
                    first: { '1': 2, '12': 5, '17': 3, '19': 5, 'bar': 0, 'off': 0 },
                    second: { '6': 5, '8': 3, '13': 5, '24': 2, 'bar': 0, 'off': 0 }
                };
            } else {
                return {
                    first: { '24': 2, '6': 5, '8': 3, '13': 5, 'bar': 0, 'off': 0 },
                    second: { '1': 2, '19': 5, '17': 3, '12': 5, 'bar': 0, 'off': 0 }
                };
            }
        }

        function drawBoard() {
            if (!dataLoaded) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(boardImg, 0, 0, canvas.width, canvas.height);

            let positions;
            if (current === 0) {
                positions = getInitialPositions(inverted);
            } else {
                const prevTurn = current - 1;
                positions = inverted ? data[prevTurn].inverted_positions : data[prevTurn].positions;
            }

            invertColors = inverted;

            // Подсветка номеров только для текущего игрока (после хода)
            const currentTurn = data[current];
            const currentPlayerType = currentTurn ? currentTurn.turn : null;

            drawCheckers('first', whiteChecker, positions.first, currentPlayerType);
            drawCheckers('second', blackChecker, positions.second, currentPlayerType);

            // Кубики только в финальном положении
            if (currentTurn && currentTurn.dice && currentTurn.dice.length >= 2 && !['double', 'take', 'win'].includes(currentTurn.action || '')) {
                const [d1, d2] = currentTurn.dice;
                const diceY = 350;
                let diceX1, diceX2, diceSet;
                if (invertColors) {
                    diceSet = currentPlayerType === 'first' ? diceImages.white : diceImages.black;
                    diceX1 = currentPlayerType === 'first' ? 130 : 530;
                    diceX2 = currentPlayerType === 'first' ? 220 : 620;
                } else {
                    diceSet = currentPlayerType === 'first' ? diceImages.white : diceImages.black;
                    diceX1 = currentPlayerType === 'first' ? 530 : 130;
                    diceX2 = currentPlayerType === 'first' ? 620 : 220;
                }
                ctx.drawImage(diceSet[d1], diceX1, diceY, 60, 60);
                ctx.drawImage(diceSet[d2], diceX2, diceY, 60, 60);
            }
        }

        function drawCheckers(player, img, positions, currentPlayer) {
            ctx.font = 'bold 30px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Подсвечиваем номера точек только если это текущий игрок
            if (player === currentPlayer) {
                for (let point = 1; point <= 24; point++) {
                    const x = getX(point);
                    let numberY = (point > 12) ? getBaseY(point) - 50 : getBaseY(point) + 60;
                    let displayPoint = point;
                    if (invertColors) {
                        displayPoint = (player === 'first') ? 25 - point : point;
                    } else {
                        displayPoint = (player === 'second') ? 25 - point : point;
                    }
                    ctx.fillText(displayPoint, x, numberY);
                }
            }

            // Отрисовка шашек на точках
            for (let pointStr in positions) {
                if (pointStr === 'bar' || pointStr === 'off') continue;
                const point = parseInt(pointStr);
                const count = positions[pointStr];
                const x = getX(point);
                const y = getBaseY(point);
                const dy = getDy(point);

                for (let i = 0; i < Math.min(count, 6); i++) {
                    ctx.drawImage(img, x - 31.25, y + i * dy - 31.25, 62.5, 62.5);
                }
                if (count > 6) {
                    ctx.fillText(`${count}`, x + 40, y + 5 * dy + 5);
                }
            }

            // Bar
            if (positions.bar && positions.bar !== 0) {
                const barX = 400;
                const barY = (player === 'second') ? 220 : 520;
                const barDy = (player === 'second') ? 55 : -55;
                let y = barY;
                for (let i = 0; i < Math.min(Math.abs(positions.bar), 6); i++) {
                    ctx.drawImage(img, barX - 31.25, y + i * barDy - 31.25, 62.5, 62.5);
                }
                if (Math.abs(positions.bar) > 6) {
                    ctx.fillText(`(${Math.abs(positions.bar)})`, barX + 30, barY + 5 * barDy + 5);
                }
            }

            // Off
            if (positions.off && positions.off !== 0) {
                const offX = 783;
                const offY = invertColors ? (player === 'second' ? 440 : 340) : (player === 'second' ? 340 : 440);
                const originalFont = ctx.font;
                ctx.font = 'bold 32px Arial';
                ctx.fillText(`${positions.off}`, offX, offY);
                ctx.font = originalFont;
            }
        }

        // Функции getX, getBaseY, getDy без изменений
        function getX(point) {
            if (point >= 13 && point <= 18) return 50 + (point - 13) * 60 - (point === 13 ? 8 : 0);
            if (point >= 19 && point <= 24) return 450 + (point - 19) * 60;
            if (point >= 7 && point <= 12) return 50 + (12 - point) * 60 - (point === 12 ? 4 : 0);
            if (point >= 1 && point <= 6) return 450 + (6 - point) * 60;
            return 0;
        }
        function getBaseY(point) { return point > 12 ? 70 : 690; }
        function getDy(point) { return point > 12 ? 55 : -55; }

        // Отрисовка доски только с шашками (без номеров и кубиков) — для анимации
        function drawBoardForAnimation(positions) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(boardImg, 0, 0, canvas.width, canvas.height);
            invertColors = inverted;
            drawCheckers('first', whiteChecker, positions.first, null);  // null — без подсветки номеров
            drawCheckers('second', blackChecker, positions.second, null);
        }

        // Остальные функции анимации (animateSingleMove, animateHit, updateTempPositionsAfterMove) — без изменений
        // (я их оставляю такими же, как в предыдущей версии)

        function animateSingleMove(move, playerType, temp_positions, callback) {
            const img = playerType === 'first' ? whiteChecker : blackChecker;
            const player_pos = temp_positions[playerType];

            let fromX, fromY;
            if (move.from === 'bar' || move.from === 'bar') {
                fromX = 400;
                const barY = playerType === 'second' ? 220 : 520;
                const barDy = playerType === 'second' ? 55 : -55;
                const count = Math.abs(player_pos.bar || 0);
                fromY = barY + (count - 1) * barDy;
            } else {
                const p = parseInt(move.from);
                fromX = getX(p);
                const count = player_pos[move.from] || 0;
                fromY = getBaseY(p) + (count - 1) * getDy(p);
            }

            let toX, toY;
            if (move.to === 'off') {
                toX = 783;
                toY = invertColors ? (playerType === 'second' ? 440 : 340) : (playerType === 'second' ? 340 : 440);
            } else {
                const p = parseInt(move.to);
                toX = getX(p);
                let count = player_pos[move.to] || 0;
                if (move.hit) count = 0;
                toY = getBaseY(p) + count * getDy(p);
            }

            let progress = 0;
            const duration = 800;
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);
                const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                const cx = fromX + (toX - fromX) * eased;
                const cy = fromY + (toY - fromY) * eased;

                drawBoardForAnimation(temp_positions);
                ctx.drawImage(img, cx - 31.25, cy - 31.25, 62.5, 62.5);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    callback(move.hit || false);
                }
            };
            animate();
        }

        function animateHit(move, playerType, temp_positions, callback) {
            const hitPlayer = playerType === 'first' ? 'second' : 'first';
            const img = hitPlayer === 'first' ? whiteChecker : blackChecker;

            const p = parseInt(move.to);
            const fromX = getX(p);
            const fromY = getBaseY(p) + (0) * getDy(p); // верхняя шашка (всегда одна при хите)

            const barX = 400;
            const barY = hitPlayer === 'second' ? 220 : 520;
            const barDy = hitPlayer === 'second' ? 55 : -55;
            const barCount = Math.abs(temp_positions[hitPlayer].bar || 0);
            const toY = barY + barCount * barDy;

            let progress = 0;
            const duration = 600;
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);
                const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                const cx = fromX + (barX - fromX) * eased;
                const cy = fromY + (toY - fromY) * eased;

                drawBoardForAnimation(temp_positions);
                ctx.drawImage(img, cx - 31.25, cy - 31.25, 62.5, 62.5);

                if (progress < 1) requestAnimationFrame(animate);
                else callback();
            };
            animate();
        }

        function updateTempPositionsAfterMove(move, playerType, temp_positions) {
            const player_pos = temp_positions[playerType];
            const opp_pos = temp_positions[playerType === 'first' ? 'second' : 'first'];
            const from = move.from.toString();
            const to = move.to.toString();

            // Убираем с from
            if (from === 'bar') {
                player_pos.bar = (player_pos.bar || 0) - 1;
                if (player_pos.bar === 0) delete player_pos.bar;
            } else {
                player_pos[from] -= 1;
                if (player_pos[from] === 0) delete player_pos[from];
            }

            // Если был хит — убираем одну шашку противника и ставим на bar
            if (move.hit) {
                if (opp_pos[to] === 1) delete opp_pos[to];
                else opp_pos[to] -= 1;
                opp_pos.bar = (opp_pos.bar || 0) + 1;
            }

            // Ставим на to
            if (to === 'off') {
                player_pos.off = (player_pos.off || 0) + 1;
            } else {
                player_pos[to] = (player_pos[to] || 0) + 1;
            }
        }

        function animateToNext() {
            if (current >= data.length - 1 || animating) return;
            animating = true;
            updateButtons();

            const nextTurn = data[current + 1];
            const playerType = nextTurn.turn;

            let start_positions;
            if (current === 0) {
                start_positions = getInitialPositions(inverted);
            } else {
                start_positions = inverted ? data[current - 1].inverted_positions : data[current - 1].positions;
            }

            const temp_positions = JSON.parse(JSON.stringify(start_positions));

            if (!nextTurn.moves || nextTurn.moves.length === 0) {
                current++;
                drawBoard();
                updateInfo();
                updateButtons();
                animating = false;
                return;
            }

            let moveIdx = 0;
            const playNextMove = () => {
                if (moveIdx >= nextTurn.moves.length) {
                    current++;
                    drawBoard();         // финальная отрисовка с кубиками и правильной подсветкой
                    updateInfo();
                    updateButtons();
                    animating = false;
                    return;
                }

                const move = nextTurn.moves[moveIdx];
                animateSingleMove(move, playerType, temp_positions, (hasHit) => {
                    if (hasHit) {
                        animateHit(move, playerType, temp_positions, () => {
                            updateTempPositionsAfterMove(move, playerType, temp_positions);
                            moveIdx++;
                            setTimeout(playNextMove, 350);
                        });
                    } else {
                        updateTempPositionsAfterMove(move, playerType, temp_positions);
                        moveIdx++;
                        setTimeout(playNextMove, 350);
                    }
                });
            };

            playNextMove();
        }

        function animateToPrev() {
            if (current <= 0 || animating) return;
            animating = true;
            updateButtons();
            current--;
            drawBoard();
            updateInfo();
            updateButtons();
            animating = false;
        }

        // updateButtons, updateInfo, event listeners — без изменений

        function updateButtons() {
            document.getElementById('prevBtn').disabled = current === 0 || animating;
            document.getElementById('nextBtn').disabled = current === data.length - 1 || animating;
        }

        function updateInfo() {
            if (!dataLoaded) return;
            document.getElementById('turnLabel').textContent = current + 1;

            const moveInfo = document.getElementById('moveInfo');
            const turn = data[current];
            const game = availableGames.find(g => g.game_number === currentGameNum);
            const playerName = turn && turn.turn ? (turn.turn === 'first' ? game.first_player : game.second_player) : '';
            const prefix = playerName ? `${playerName}: ` : '';

            if (turn && turn.moves && turn.moves.length > 0) {
                const movesStr = turn.moves.map(m => `${m.from}/${m.to}${m.hit ? '*' : ''}`).join(' ');
                moveInfo.textContent = prefix + movesStr;
            } else if (turn && turn.action) {
                moveInfo.textContent = prefix + turn.action;
            } else {
                moveInfo.textContent = 'Initial Position';
            }
        }

        // Event listeners (без изменений)
        document.getElementById('prevBtn').addEventListener('click', animateToPrev);
        document.getElementById('nextBtn').addEventListener('click', animateToNext);
        document.getElementById('invertBtn').addEventListener('click', () => { inverted = !inverted; drawBoard(); });
        document.getElementById('gameSelect').addEventListener('change', (e) => {
            const idx = parseInt(e.target.value);
            currentGameNum = idx + 1;
            data = availableGames[idx].turns;
            current = 0;
            inverted = false;
            drawBoard();
            updateButtons();
            updateInfo();
        });

        // Загрузка изображений (без изменений)
        let imagesLoaded = 0;
        const totalImages = 15;
        function imageLoaded() {
            imagesLoaded++;
            if (imagesLoaded === totalImages && dataLoaded) drawBoard();
        }
        [boardImg, whiteChecker, blackChecker, Dice1w,Dice2w,Dice3w,Dice4w,Dice5w,Dice6w,Dice1b,Dice2b,Dice3b,Dice4b,Dice5b,Dice6b]
            .forEach(img => img.onload = imageLoaded);
    </script>
</body>

</html>